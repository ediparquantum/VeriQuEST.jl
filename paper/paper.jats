<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN"
                  "JATS-publishing1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.2" article-type="other">
<front>
<journal-meta>
<journal-id></journal-id>
<journal-title-group>
<journal-title>Journal of Open Source Software</journal-title>
<abbrev-journal-title>JOSS</abbrev-journal-title>
</journal-title-group>
<issn publication-format="electronic">2475-9066</issn>
<publisher>
<publisher-name>Open Journals</publisher-name>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">0</article-id>
<article-id pub-id-type="doi">N/A</article-id>
<title-group>
<article-title>VeriQuEST.jl: Emulating verification of quantum
computations with QuEST</article-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" equal-contrib="yes">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0002-5836-1736</contrib-id>
<name>
<surname>Miller</surname>
<given-names>Jonathan</given-names>
</name>
<xref ref-type="aff" rid="aff-1"/>
</contrib>
<contrib contrib-type="author" equal-contrib="yes">
<name>
<surname>Leichtle</surname>
<given-names>Dominik</given-names>
</name>
<xref ref-type="aff" rid="aff-2"/>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Kashefi</surname>
<given-names>Elham</given-names>
</name>
<xref ref-type="aff" rid="aff-2"/>
</contrib>
<contrib contrib-type="author">
<name>
<surname>Gustiani</surname>
<given-names>Cica</given-names>
</name>
<xref ref-type="aff" rid="aff-2"/>
</contrib>
<aff id="aff-1">
<institution-wrap>
<institution>School of Informatics, University of Edinburgh, 10 Crichton
Street, Edinburgh EH8 9AB, United Kingdom</institution>
</institution-wrap>
</aff>
<aff id="aff-2">
<institution-wrap>
<institution>Laboratoire d’Informatique de Paris 6, CNRS, Sorbonne
Université, 4 Place Jussieu, Paris 75005, France</institution>
</institution-wrap>
</aff>
</contrib-group>
<pub-date date-type="pub" publication-format="electronic" iso-8601-date="2024-01-29">
<day>29</day>
<month>1</month>
<year>2024</year>
</pub-date>
<volume>¿VOL?</volume>
<issue>¿ISSUE?</issue>
<fpage>¿PAGE?</fpage>
<permissions>
<copyright-statement>Authors of papers retain copyright and release the
work under a Creative Commons Attribution 4.0 International License (CC
BY 4.0)</copyright-statement>
<copyright-year>2022</copyright-year>
<copyright-holder>The article authors</copyright-holder>
<license license-type="open-access" xlink:href="https://creativecommons.org/licenses/by/4.0/">
<license-p>Authors of papers retain copyright and release the work under
a Creative Commons Attribution 4.0 International License (CC BY
4.0)</license-p>
</license>
</permissions>
<kwd-group kwd-group-type="author">
<kwd>Julia</kwd>
<kwd>quantum computing</kwd>
<kwd>measurement based quantum computing</kwd>
<kwd>blind quantum computing</kwd>
<kwd>quantum verification</kwd>
<kwd>emulation</kwd>
<kwd>noise</kwd>
<kwd>decoherence</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="summary">
  <title>Summary</title>
  <p>Within the practical context of quantum computing, the
  <italic>client-server</italic> framework is anticipated to become
  predominant in the future due to the high costs, intensive
  maintenance, and operational complexity of quantum computers. In this
  framework, a client with a very limited quantum power, so-called
  Alice, delegates her quantum computation to a powerful quantum server,
  so-called Bob, who then provides Alice her computation results. While
  this scenario appears practical, it raises significant security
  concern: how do we ensure Bob follows Alice’s instructions and confirm
  the reliability of his quantum computer? These questions undeniably
  pose significant challenges and remain under active investigation;
  <italic>verifiable quantum computations</italic> is a subfield of
  quantum computing that aims to address these concerns.</p>
  <p>This paper introduces <monospace>VeriQuEST.jl</monospace>, a Julia
  package equipped with functionalities to emulate verification
  protocols for quantum computation
  (<xref alt="Gheorghiu et al., 2019" rid="ref-gheorghiu2019verification" ref-type="bibr">Gheorghiu
  et al., 2019</xref>) within the framework of measurement-based quantum
  computations
  (<xref alt="Raussendorf &amp; Briegel, 2001" rid="ref-raussendorf2001one" ref-type="bibr">Raussendorf
  &amp; Briegel, 2001</xref>). The package utilizes QuEST
  (<xref alt="Jones et al., 2019" rid="ref-QuESTJones2019" ref-type="bibr">Jones
  et al., 2019</xref>) as its backend, a versatile quantum computer
  emulator (including noise simulation) written in C, while supporting
  high-performance computations. VeriQuEST.jl is designed to aid
  researchers in testing their verification protocols or concepts on
  emulated quantum systems. This approach allows them to assess
  performance estimates without the need for actual hardware, which, at
  the time of writing this paper, is significantly limited.</p>
</sec>
<sec id="statement-of-need">
  <title>Statement of need</title>
  <p>Our package <monospace>VeriQuEST.jl</monospace> is aimed at
  assisting researchers in exploring and designing their verification
  protocols within the paradigm of <italic>measurement-based quantum
  computation</italic> (MBQC). The conventional way to express quantum
  algorithms is through a series of unitary operations and measurements,
  so-called <italic>gate-based</italic> computations
  (<xref alt="Nielsen &amp; Chuang, 2011" rid="ref-nielsenchuang" ref-type="bibr">Nielsen
  &amp; Chuang, 2011</xref>). On the other hand, MBQC uses a
  <italic>graph state</italic> as the resource and a series of adaptive
  single-qubit measurements to realise a quantum algorithm. While
  gate-based emulators – such as <monospace>QuEST</monospace> – are
  predomonant, MBQC emulators remain scarce. Our package, VeriQuEST.jl,
  offers an interface that enables users to express their verification
  protocols and quantum algorithms in the native MBQC language,
  supporting interactive protocols, such as verifications, that require
  a quantum internet, powered by a performant backend
  <monospace>QuEST</monospace>
  (<xref alt="Jones et al., 2019" rid="ref-QuESTJones2019" ref-type="bibr">Jones
  et al., 2019</xref>). Moreover, to this date, there is no emulator
  that is specifically aimed at simulating verification protocols.</p>
</sec>
<sec id="core-features-and-functionality">
  <title>Core features and functionality</title>
  <p><monospace>VeriQuEST.jl</monospace> is equipped with fundamental
  functionalities to support the testing of various verification
  protocols of quantum computations based on MBQC. The package
  <monospace>VeriQuEST.jl</monospace> contains three fundamental
  elements to support emulation of verification protocols: MBQC
  computations, multi-round interactions between client and server, and
  Hilbert space partition to realize the explicit client-server
  separation. The package allows for (noiseless) state vector and
  (noisy) density matrix simulations. In the current release, we provide
  several well-known MBQCs and verification protocols ready for the
  users to use. If one wishes to become acquainted with the details, see
  the public GitHub repository for
  <ext-link ext-link-type="uri" xlink:href="https://github.com/fieldofnodes/VeriQuEST.jl"><monospace>VeriQuEST</monospace></ext-link>.</p>
  <sec id="software-architecture">
    <title>Software architecture</title>
    <p>VeriQuEST.jl is a package written entirely in
    <monospace>Julia</monospace>, however to emulate the quantum
    computation, the <monospace>C</monospace> wrapper
    <monospace>QuEST.jl</monospace> which utilises the library
    <monospace>QuEST</monospace> is used.
    <monospace>QuEST.jl</monospace> calls the <monospace>C</monospace>
    through a precompiled verions (<monospace>v3.7</monospace>) of
    <monospace>QuEST</monospace>, with a number of features on the
    <monospace>Julia</monospace> level to prevent run-time crashes.
    There are some experimental features, but basic usage and
    specifically calls relevant to <monospace>VeriQuEST.jl</monospace>
    are sound. The user takes advantage of the
    <monospace>Julia</monospace> just-in-time compilation and can run
    scripts or functions per standard <monospace>Julia</monospace>
    usage. There are many functions not automatically exported to the
    user but available in the normal way (e.g., calling
    <monospace>VeriQuEST.&lt;function/struct/type-call&gt;</monospace>).
    <monospace>QuEST</monospace> can be compiled to run on multi-core,
    multi-threads, distributed and GPU clusters, however here
    <monospace>QuEST.jl</monospace> uses pre-compiled binaries suited
    for multi-threading only.</p>
    <fig>
      <caption><p>Software architecture</p></caption>
      <graphic mimetype="image" mime-subtype="png" xlink:href="media/media/verification_software_stack.png" />
    </fig>
    <fig>
      <caption><p>Network architecture</p></caption>
      <graphic mimetype="image" mime-subtype="png" xlink:href="media/media/network_per_computation_type.png" />
    </fig>
  </sec>
  <sec id="measurement-based-quantum-computation-mbqc">
    <title>Measurement-Based Quantum Computation (MBQC)</title>
    <p>In the MBQC framework, a quantum algorithm can be represented as
    a set <inline-formula><alternatives>
    <tex-math><![CDATA[\{(G, I, O), \vec{\phi}\}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mover><mml:mi>ϕ</mml:mi><mml:mo accent="true">⃗</mml:mo></mml:mover><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>,
    where <inline-formula><alternatives>
    <tex-math><![CDATA[(G, I, O)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
    denotes the quantum resource and <inline-formula><alternatives>
    <tex-math><![CDATA[\vec{\phi}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mover><mml:mi>ϕ</mml:mi><mml:mo accent="true">⃗</mml:mo></mml:mover></mml:math></alternatives></inline-formula>
    is a set of measurement angles. The triplet
    <inline-formula><alternatives>
    <tex-math><![CDATA[(G, I, O)]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
    signifies an <italic>open graph</italic>, i.e., graphs characterised
    by the presence of <italic>flow</italic>
    (<xref alt="Danos &amp; Kashefi, 2006" rid="ref-danos2006determinism" ref-type="bibr">Danos
    &amp; Kashefi, 2006</xref>). Single-qubit adaptive measurements are
    performed sequentially on the vertices with measurement operator
    <inline-formula><alternatives>
    <tex-math><![CDATA[\{|+_{\theta_j}\rangle\!\langle +_{\theta_j}|,|-_{\theta_j}\rangle\!\langle -_{\theta_j}|\}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">|</mml:mo><mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:msub><mml:mo stretchy="false" form="postfix">⟩</mml:mo><mml:mspace width="-0.167em"></mml:mspace><mml:mo stretchy="false" form="prefix">⟨</mml:mo><mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:msub><mml:mo stretchy="true" form="postfix">|</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">|</mml:mo><mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:msub><mml:mo stretchy="false" form="postfix">⟩</mml:mo><mml:mspace width="-0.167em"></mml:mspace><mml:mo stretchy="false" form="prefix">⟨</mml:mo><mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:msub><mml:mo stretchy="true" form="postfix">|</mml:mo></mml:mrow><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>,
    measured on vertex <inline-formula><alternatives>
    <tex-math><![CDATA[j]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>j</mml:mi></mml:math></alternatives></inline-formula>,
    where <inline-formula><alternatives>
    <tex-math><![CDATA[|\pm_{\theta}\rangle\coloneq (|0\rangle\pm e^{i\theta}|1\rangle)/\sqrt{2}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:msub><mml:mo>±</mml:mo><mml:mi>θ</mml:mi></mml:msub><mml:mo stretchy="false" form="postfix">⟩</mml:mo><mml:mo>≔</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">|</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false" form="postfix">⟩</mml:mo><mml:mo>±</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>θ</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="true" form="postfix">|</mml:mo></mml:mrow><mml:mn>1</mml:mn><mml:mo stretchy="false" form="postfix">⟩</mml:mo><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>/</mml:mi><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt></mml:mrow></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives>
    <tex-math><![CDATA[\theta_j=\phi_j+\delta]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mi>δ</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    for a correction <inline-formula><alternatives>
    <tex-math><![CDATA[\delta]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>δ</mml:mi></mml:math></alternatives></inline-formula>
    that is calculated by our tool. For an illustration, see
    <xref alt="[fig:graph]" rid="figU003Agraph">[fig:graph]</xref>.</p>
    <fig>
      <caption><p>The triplet <inline-formula><alternatives>
      <tex-math><![CDATA[(G, I, O)]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
      representing graph state for the quantum resource, where
      <inline-formula><alternatives>
      <tex-math><![CDATA[G=(V,E)]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
      is the graph, <inline-formula><alternatives>
      <tex-math><![CDATA[I]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>I</mml:mi></mml:math></alternatives></inline-formula>
      is a set of input nodes, and <inline-formula><alternatives>
      <tex-math><![CDATA[O]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>O</mml:mi></mml:math></alternatives></inline-formula>
      is a set of output nodes. Each node represents qubit with state
      <inline-formula><alternatives>
      <tex-math><![CDATA[(|0\rangle+|1\rangle)/\sqrt 2]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">|</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false" form="postfix">⟩</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="true" form="postfix">|</mml:mo></mml:mrow><mml:mn>1</mml:mn><mml:mo stretchy="false" form="postfix">⟩</mml:mo><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>/</mml:mi><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt></mml:mrow></mml:math></alternatives></inline-formula>
      and each edge represent controlled-<inline-formula><alternatives>
      <tex-math><![CDATA[Z]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>Z</mml:mi></mml:math></alternatives></inline-formula>
      operation operated to the corresponding nodes. Measurements in the
      <inline-formula><alternatives>
      <tex-math><![CDATA[XY]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>X</mml:mi><mml:mi>Y</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>-plane
      of Bloch sphere are performed from the left to the right. The
      arrows indicate the <italic>flow</italic>
      <inline-formula><alternatives>
      <tex-math><![CDATA[f:O^c\rightarrow I^c]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>f</mml:mi><mml:mo>:</mml:mo><mml:msup><mml:mi>O</mml:mi><mml:mi>c</mml:mi></mml:msup><mml:mo>→</mml:mo><mml:msup><mml:mi>I</mml:mi><mml:mi>c</mml:mi></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>
      which induces partial ordering of the measurements. Input nodes
      <inline-formula><alternatives>
      <tex-math><![CDATA[I]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>I</mml:mi></mml:math></alternatives></inline-formula>
      may be initialised to an arbitrary quantum state
      <inline-formula><alternatives>
      <tex-math><![CDATA[\rho]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>ρ</mml:mi></mml:math></alternatives></inline-formula>
      and the output nodes <inline-formula><alternatives>
      <tex-math><![CDATA[O]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi>O</mml:mi></mml:math></alternatives></inline-formula>
      is the final output that can be classical or quantum – if left
      unmeasured.
      <styled-content id="figU003Agraph"></styled-content></p></caption>
      <graphic mimetype="image" mime-subtype="jpeg" xlink:href="media/graph.jpg" />
    </fig>
    <sec id="configuration">
      <title>Configuration</title>
      <p>In this example a simple path graph is implemented.</p>
      <code language="julia">using Pkg
Pkg.activate(&quot;.&quot;)
using VeriQuEST
using Graphs
# Set up input values
graph = Graph(2)
add_edge!(graph,1,2)


io = InputOutput(Inputs(),Outputs(2))
qgraph = QuantumGraph(graph,io)
function forward_flow(vertex)
    v_str = string(vertex)
    forward = Dict(
        &quot;1&quot; =&gt;2,
        &quot;2&quot;=&gt;0)
    forward[v_str]
end
flow = Flow(forward_flow)
measurement_angles = Angles([π/2,π/2])</code>
      <p>To run the MBQC pattern</p>
      <code language="julia">mbqc_comp_type = MeasurementBasedQuantumComputation(qgraph,flow,measurement_angles)
no_network = NoNetworkEmulation()
dm = DensityMatrix()
sv = StateVector()
ch = NoisyChannel(NoNoise(NoQubits()))
cr = MBQCRound()</code>
      <p>Run as state vector</p>
      <code language="julia">mg_dm = compute!(mbqc_comp_type,no_network,sv,ch,cr)</code>
      <p>and as density matrix</p>
      <code language="julia">mg_sv = compute!(mbqc_comp_type,no_network,dm,ch,cr)</code>
    </sec>
  </sec>
  <sec id="blind-quantum-computation-bqc">
    <title>Blind Quantum Computation (BQC)</title>
    <p>Blind Quantum Computation (BQC) is a type of cryptographic
    protocol that enables a client, referred to as Alice, to securely
    delegate her quantum computing tasks to a powerful quantum server,
    called Bob, while ensuring privacy. Within this setup, Bob cannot
    infer Alice’s algorithm nor her measurement outcomes. The most
    notable BQC protocol is the Universal Blind Quantum Computation
    (UBQC)(<xref alt="Broadbent et al., 2009" rid="ref-broadbent2009universal" ref-type="bibr">Broadbent
    et al., 2009</xref>). This framework allows Alice to privately
    delegate her MBQC algorithm to Bob through a series of quantum and
    classical interactions between them.</p>
    <p>Remarkably, the UBQC promises composable security that does not
    rely on traditional computational assumptions
    (<xref alt="Dunjko et al., 2014" rid="ref-dunjko2014composable" ref-type="bibr">Dunjko
    et al., 2014</xref>). Instead, the privacy stems directly from the
    intrinsic properties of quantum measurement. In this model, Alice
    requires only limited quantum resources: the ability to prepare
    specific quantum states, <inline-formula><alternatives>
    <tex-math><![CDATA[|+_\theta\rangle]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:msub><mml:mo>+</mml:mo><mml:mi>θ</mml:mi></mml:msub><mml:mo stretchy="false" form="postfix">⟩</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>,
    and to send them to Bob, underscoring the necessity for a robust
    quantum network. The essence of maintaining Alice’s privacy lies in
    obfuscating the measurement angles <inline-formula><alternatives>
    <tex-math><![CDATA[\vec{\phi}]]></tex-math>
    <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mover><mml:mi>ϕ</mml:mi><mml:mo accent="true">⃗</mml:mo></mml:mover></mml:math></alternatives></inline-formula>
    and the associated outcomes through the strategic use of randomness,
    as illustrated in
    <xref alt="[fig:client-server]" rid="figU003Aclient-server">[fig:client-server]</xref>.</p>
    <fig>
      <caption><p>This circuit shows task separation between the client
      and the hiding strategy, where measurement angles
      <inline-formula><alternatives>
      <tex-math><![CDATA[\{\phi_j\}]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
      and initial outcomes <inline-formula><alternatives>
      <tex-math><![CDATA[\{s_j\}]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
      are obscured. Additional randomness (highlighted in red) is
      introduced for hiding the secrets, which later neutralised by
      adjustments in <inline-formula><alternatives>
      <tex-math><![CDATA[\delta_j]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>δ</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
      to hide the measurement angles <inline-formula><alternatives>
      <tex-math><![CDATA[\phi_j]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:math></alternatives></inline-formula>.
      Notice that the actual measurement outcomes
      <inline-formula><alternatives>
      <tex-math><![CDATA[s_j]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>s</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
      remain exclusively accessible to Alice due to random binary
      <inline-formula><alternatives>
      <tex-math><![CDATA[r_j]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>r</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:math></alternatives></inline-formula>.
      Note that the first state <inline-formula><alternatives>
      <tex-math><![CDATA[|\psi\rangle]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="false" form="prefix">|</mml:mo><mml:mi>ψ</mml:mi><mml:mo stretchy="false" form="postfix">⟩</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
      indicates an arbitrary input state that is encrypted by random
      phase <inline-formula><alternatives>
      <tex-math><![CDATA[\alpha_0]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>α</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
      and random bit flip <inline-formula><alternatives>
      <tex-math><![CDATA[t_1]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>t</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></alternatives></inline-formula>;
      thus, <inline-formula><alternatives>
      <tex-math><![CDATA[\delta_0=(-1)^{t_1}+\alpha_0+r_0]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>δ</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msup><mml:mo>+</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>.
      In the MBQC language, this circuit is equivalent with the three
      nodes path graph with angles <inline-formula><alternatives>
      <tex-math><![CDATA[\{\alpha_0,\alpha_1,\alpha_2\}]]></tex-math>
      <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>.
      <styled-content id="figU003Aclient-server"></styled-content></p></caption>
      <graphic mimetype="application" mime-subtype="pdf" xlink:href="media/client-server.pdf" />
    </fig>
    <p>In BQC, delegating quantum tasks privately highlights the
    importance of client state preparation, state transfer,
    accessibility, correctness, and security. To address these critical
    aspects efficiently, end users are presented with two approaches for
    emulating BQC algorithms:</p>
    <list list-type="bullet">
      <list-item>
        <p><bold>Implicit network emulation</bold>. In this option, we
        do not explicitly emulate the quantum state of the client or the
        quantum network. Instead, the states prepared on the server side
        already take into account the state transfer. This approach is
        useful for studying the noise effect on the computation. For an
        example, see the code below.</p>
      </list-item>
    </list>
    <code language="julia">ubqc_comp_type = BlindQuantumComputation(qgraph,flow,measurement_angles)
dm = DensityMatrix()
implicit_network = ImplicitNetworkEmulation()
cr = ComputationRound()
mg_imp = compute!(ubqc_comp_type,implicit_network,dm,ch,cr)</code>
    <list list-type="bullet">
      <list-item>
        <p><bold>Explicit network emulation</bold>. In this option, the
        quantum state of the client and the state transfer are
        explicitly emulated. The quantum network is simulated using
        remote entanglement operators, which can also be specified by
        the end user. This is made possible by operators operating
        between the client and the server in the joint Hilbert space of
        the client and the server, denoted as
        <inline-formula><alternatives>
        <tex-math><![CDATA[\mathcal H_c \otimes \mathcal H_s]]></tex-math>
        <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>ℋ</mml:mi><mml:mi>c</mml:mi></mml:msub><mml:mo>⊗</mml:mo><mml:msub><mml:mi>ℋ</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>.
        This approach is useful for studying the effects of noise on the
        protocol as well as examining security in greater detail.
        Additionally, users can access the state of each party: the
        client’s state in <inline-formula><alternatives>
        <tex-math><![CDATA[\mathcal H_c]]></tex-math>
        <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>ℋ</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
        and the server’s state in <inline-formula><alternatives>
        <tex-math><![CDATA[\mathcal H_s]]></tex-math>
        <mml:math display="inline" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mi>ℋ</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:math></alternatives></inline-formula>,
        enabled by the partial trace operation. For an example, see the
        code below. [JON:CODE SNIPPET with explicit client]</p>
      </list-item>
    </list>
    <code language="julia">bell_pair_explicit_network = BellPairExplicitNetwork()
mg_bp = compute!(ubqc_comp_type,bell_pair_explicit_network,dm,ch,cr)</code>
  </sec>
  <sec id="verification-protocols-dom">
    <title>Verification protocols [DOM]</title>
    <p>The verification protocol can be added on top of BQC, certifying
    the executed quantum algorithm.</p>
    <p>Introduce verification and.</p>
    <p>Our tool provides several verification protocols that are ready
    for users to use:</p>
    <list list-type="bullet">
      <list-item>
        <p>Dominik’s BQP verification
        (<xref alt="Leichtle et al., 2021" rid="ref-PRXQuantum.2.040302" ref-type="bibr">Leichtle
        et al., 2021</xref>)</p>
      </list-item>
      <list-item>
        <p>Maybe Fitsimons verification with hidden trap?</p>
      </list-item>
    </list>
    <p>To run the verification on a noisless server</p>
    <code language="julia">flow = Flow(forward_flow)
measurement_angles = Angles([π/2,π/2])
total_rounds = 10
computation_rounds = 1
trapification_strategy = TestRoundTrapAndDummycolouring()
ct = LeichtleVerification(
    total_rounds,
    computation_rounds,
    trapification_strategy,
    qgraph,flow,measurement_angles)
nt_bp = BellPairExplicitNetwork()
nt_im = ImplicitNetworkEmulation()
st = DensityMatrix()
ch = NoisyChannel(NoNoise(NoQubits()))</code>
    <p>Run on an implicit network</p>
    <code language="julia">ver_res1 = run_verification_simulator(ct,nt_bp,st,ch)</code>
    <p>and an explicit network</p>
    <code language="julia">ver_res2 = run_verification_simulator(ct,nt_im,st,ch)</code>
    <p>To get results</p>
    <code language="julia">get_tests(ver_res2) 
get_computations(ver_res2)
get_tests_verbose(ver_res2)
get_computations_verbose(ver_res2) 
get_computations_mode(ver_res2) </code>
    <preformat>
## Noiseless and noisy simulations

In the study of quantum verification protocols, it is crucial to be able to simulate both state vector and density matrix simulations. State vector simulations require less computational space, e.g., $n$-qubit system has dimension $2^n$, making it easier to check if the protocols are correct. On the other hand, density matrix simulations requires more computational space, e.g., $n$-qubit system has dimension $2^n\times 2^n$, however, they are excellent for understanding how noise impacts the whole protocol, affecting both its certification and security. Such features help researcher to ensuring their protocols are both correct and secure in the presence of noise. Some examples on the  density matrix simulations are given below. 

### Implicit noise channels

Here are examples of bit flip noise and angles added to measurement basis 

```julia
# Post Angle Update
angle = 0.1
model = PostAngleUpdate(SingleQubit(),angle)
ch = NoisyChannel(model)
vr = run_verification_simulator(ct,nt_im,st,ch)
vr = run_verification_simulator(ct,nt_bp,st,ch)
st = StateVector()
vr = run_verification_simulator(ct,nt_im,st,ch)



# Add bit flip
bit_flip_prob = 0.5
model = AddBitFlip(SingleQubit(),bit_flip_prob)
ch = NoisyChannel(model)
vr = run_verification_simulator(ct,nt_im,st,ch)
vr = run_verification_simulator(ct,nt_bp,st,ch)
st = StateVector()
vr = run_verification_simulator(ct,nt_im,st,ch)
    </preformat>
    <sec id="explicit-noise-channels">
      <title>Explicit noise channels</title>
      <p>Here are examples of damping, dephasing and depolarising
      noise.</p>
      <code language="julia">
# Prob scaling
p_scale = 0.1
p = [p_scale*rand() for i in vertices(graph)]

# Damping
model = Damping(SingleQubit(),p)
ch = NoisyChannel(model)
vr = run_verification_simulator(ct,nt_im,st,ch)
vr = run_verification_simulator(ct,nt_bp,st,ch)

# Dephasing
model = Dephasing(SingleQubit(),p)
ch = NoisyChannel(model)
vr = run_verification_simulator(ct,nt_im,st,ch)
vr = run_verification_simulator(ct,nt_bp,st,ch)

# Depolarising
model = Depolarising(SingleQubit(),p)
ch = NoisyChannel(model)
vr = run_verification_simulator(ct,nt_im,st,ch)
vr = run_verification_simulator(ct,nt_bp,st,ch)

# Pauli 
p_xyz(p_scale) = p_scale/10 .* [rand(),rand(),rand()]
p = [p_xyz(p_scale) for i in vertices(graph)]
model = Pauli(SingleQubit(),p)
ch = NoisyChannel(model)
vr = run_verification_simulator(ct,nt_im,st,ch)
vr = run_verification_simulator(ct,nt_bp,st,ch)

# Vector of noise models
model_vec = [Damping,Dephasing,Depolarising,Pauli]
p_damp = [p_scale*rand() for i in vertices(graph)]
p_deph = [p_scale*rand() for i in vertices(graph)]
p_depo = [p_scale*rand() for i in vertices(graph)]
p_pauli = [p_xyz(p_scale) for i in vertices(graph)]
prob_vec = [p_damp,p_deph,p_depo,p_pauli]

models = Vector{AbstractNoiseModels}()
for m in eachindex(model_vec)
    push!(models,model_vec[m](SingleQubit(),prob_vec[m]))
end
ch = NoisyChannel(models)
vr = run_verification_simulator(ct,nt_im,st,ch)
vr = run_verification_simulator(ct,nt_bp,st,ch)</code>
    </sec>
  </sec>
</sec>
<sec id="future-plans">
  <title>Future plans</title>
  <p>Adding the upcoming verification protocols in the library.
  Multi-parties computation as per. Graph with gflow, more choice on the
  measurement plane. Minimal resource of MBQC (Lazy 1WQC). Integrating
  realistic noise. Mathematica integration.</p>
</sec>
<sec id="acknowledgements">
  <title>Acknowledgements</title>
  <p>We acknowledge contributions from QSL, NQCC,…???</p>
</sec>
</body>
<back>
<ref-list>
  <ref id="ref-danos2006determinism">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Danos</surname><given-names>Vincent</given-names></name>
        <name><surname>Kashefi</surname><given-names>Elham</given-names></name>
      </person-group>
      <article-title>Determinism in the one-way model</article-title>
      <source>Physical Review A</source>
      <publisher-name>APS</publisher-name>
      <year iso-8601-date="2006">2006</year>
      <volume>74</volume>
      <issue>5</issue>
      <pub-id pub-id-type="doi">10.1103/PhysRevA.74.052310</pub-id>
      <fpage>052310</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-nielsenchuang">
    <element-citation publication-type="book">
      <person-group person-group-type="author">
        <name><surname>Nielsen</surname><given-names>Michael A.</given-names></name>
        <name><surname>Chuang</surname><given-names>Isaac L.</given-names></name>
      </person-group>
      <source>Quantum computation and quantum information: 10th anniversary edition</source>
      <publisher-name>Cambridge University Press</publisher-name>
      <year iso-8601-date="2011">2011</year>
      <isbn>9781107002173</isbn>
      <uri>https://www.amazon.com/Quantum-Computation-Information-10th-Anniversary/dp/1107002176?SubscriptionId=AKIAIOBINVZYXZQZ2U3A&amp;tag=chimbori05-20&amp;linkCode=xm2&amp;camp=2025&amp;creative=165953&amp;creativeASIN=1107002176</uri>
    </element-citation>
  </ref>
  <ref id="ref-raussendorf2001one">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Raussendorf</surname><given-names>Robert</given-names></name>
        <name><surname>Briegel</surname><given-names>Hans J</given-names></name>
      </person-group>
      <article-title>A one-way quantum computer</article-title>
      <source>Physical review letters</source>
      <publisher-name>APS</publisher-name>
      <year iso-8601-date="2001">2001</year>
      <volume>86</volume>
      <issue>22</issue>
      <pub-id pub-id-type="doi">10.1103/PhysRevLett.86.5188</pub-id>
      <fpage>5188</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-PRXQuantum.2.040302">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Leichtle</surname><given-names>Dominik</given-names></name>
        <name><surname>Music</surname><given-names>Luka</given-names></name>
        <name><surname>Kashefi</surname><given-names>Elham</given-names></name>
        <name><surname>Ollivier</surname><given-names>Harold</given-names></name>
      </person-group>
      <article-title>Verifying BQP computations on noisy devices with minimal overhead</article-title>
      <source>PRX Quantum</source>
      <publisher-name>American Physical Society</publisher-name>
      <year iso-8601-date="2021-10">2021</year><month>10</month>
      <volume>2</volume>
      <uri>https://link.aps.org/doi/10.1103/PRXQuantum.2.040302</uri>
      <pub-id pub-id-type="doi">10.1103/PRXQuantum.2.040302</pub-id>
      <fpage>040302</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-QuESTJones2019">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Jones</surname><given-names>Tyson</given-names></name>
        <name><surname>Brown</surname><given-names>Anna</given-names></name>
        <name><surname>Bush</surname><given-names>Ian</given-names></name>
        <name><surname>Benjamin</surname><given-names>Simon C.</given-names></name>
      </person-group>
      <article-title>QuEST and high performance simulation of quantum computers</article-title>
      <source>Scientific Reports</source>
      <year iso-8601-date="2019">2019</year>
      <volume>9</volume>
      <issue>1</issue>
      <uri>https://doi.org/10.1038/s41598-019-47174-9</uri>
      <pub-id pub-id-type="doi">10.1038/s41598-019-47174-9</pub-id>
      <fpage>10736</fpage>
      <lpage></lpage>
    </element-citation>
  </ref>
  <ref id="ref-gheorghiu2019verification">
    <element-citation publication-type="article-journal">
      <person-group person-group-type="author">
        <name><surname>Gheorghiu</surname><given-names>Alexandru</given-names></name>
        <name><surname>Kapourniotis</surname><given-names>Theodoros</given-names></name>
        <name><surname>Kashefi</surname><given-names>Elham</given-names></name>
      </person-group>
      <article-title>Verification of quantum computation: An overview of existing approaches</article-title>
      <source>Theory of computing systems</source>
      <publisher-name>Springer</publisher-name>
      <year iso-8601-date="2019">2019</year>
      <volume>63</volume>
      <pub-id pub-id-type="doi">10.1007/s00224-018-9872-3</pub-id>
      <fpage>715</fpage>
      <lpage>808</lpage>
    </element-citation>
  </ref>
  <ref id="ref-broadbent2009universal">
    <element-citation publication-type="paper-conference">
      <person-group person-group-type="author">
        <name><surname>Broadbent</surname><given-names>Anne</given-names></name>
        <name><surname>Fitzsimons</surname><given-names>Joseph</given-names></name>
        <name><surname>Kashefi</surname><given-names>Elham</given-names></name>
      </person-group>
      <article-title>Universal blind quantum computation</article-title>
      <source>2009 50th annual IEEE symposium on foundations of computer science</source>
      <publisher-name>IEEE</publisher-name>
      <year iso-8601-date="2009">2009</year>
      <pub-id pub-id-type="doi">10.1109/FOCS.2009.36</pub-id>
      <fpage>517</fpage>
      <lpage>526</lpage>
    </element-citation>
  </ref>
  <ref id="ref-dunjko2014composable">
    <element-citation publication-type="paper-conference">
      <person-group person-group-type="author">
        <name><surname>Dunjko</surname><given-names>Vedran</given-names></name>
        <name><surname>Fitzsimons</surname><given-names>Joseph F</given-names></name>
        <name><surname>Portmann</surname><given-names>Christopher</given-names></name>
        <name><surname>Renner</surname><given-names>Renato</given-names></name>
      </person-group>
      <article-title>Composable security of delegated quantum computation</article-title>
      <source>International conference on the theory and application of cryptology and information security</source>
      <publisher-name>Springer</publisher-name>
      <year iso-8601-date="2014">2014</year>
      <pub-id pub-id-type="doi">10.1007/978-3-662-45608-8_22</pub-id>
      <fpage>406</fpage>
      <lpage>425</lpage>
    </element-citation>
  </ref>
</ref-list>
</back>
</article>

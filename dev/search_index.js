var documenterSearchIndex = {"docs":
[{"location":"user/grover_example/#Gorver-search-MBQC","page":"Grover example","title":"Gorver search MBQC","text":"","category":"section"},{"location":"user/grover_example/","page":"Grover example","title":"Grover example","text":"Run the following script. The search options can be 00, 01, 10 and 11. The results will be the search.","category":"page"},{"location":"user/grover_example/","page":"Grover example","title":"Grover example","text":"using VeriQuEST\n\n\nstate_type = DensityMatrix()\ntotal_rounds,computation_rounds = 100,50\n\n# Grover graph\nnum_vertices = 8\ngraph = Graph(num_vertices)\nadd_edge!(graph,1,2)\nadd_edge!(graph,2,3)\nadd_edge!(graph,3,6)\nadd_edge!(graph,6,7)\nadd_edge!(graph,1,4)\nadd_edge!(graph,4,5)\nadd_edge!(graph,5,8)\nadd_edge!(graph,7,8)\n\n\n\ninput = (indices = (),values = ())\noutput = (7,8)\n\n\n# Julia is indexed 1, hence a vertex with 0 index is flag for no flow\nfunction forward_flow(vertex)\n    v_str = string(vertex)\n    forward = Dict(\n        \"1\" =>4,\n        \"2\" =>3,\n        \"3\" =>6,\n        \"4\" =>5,\n        \"5\" =>8,\n        \"6\" =>7,\n        \"7\" =>0,\n        \"8\" =>0)\n    forward[v_str]\nend\n\n\nfunction generate_grover_secret_angles(search::String)\n\n    Dict(\"00\"=>(1.0*π,1.0*π),\"01\"=>(1.0*π,0),\"10\"=>(0,1.0*π),\"11\"=>(0,0)) |>\n    x -> x[search] |>\n    x -> [0,0,1.0*x[1],1.0*x[2],0,0,1.0*π,1.0*π] |>\n    x -> Float64.(x)\nend\n\nsearch = \"11\"\nsecret_angles = generate_grover_secret_angles(search)\n\n\n\npara= (\n    graph=graph,\n    forward_flow = forward_flow,\n    input = input,\n    output = output,\n    secret_angles=secret_angles,\n    state_type = state_type,\n    total_rounds = total_rounds,\n    computation_rounds = computation_rounds)","category":"page"},{"location":"user/grover_example/","page":"Grover example","title":"Grover example","text":"To run MBQC, UBQC and VBQC","category":"page"},{"location":"user/grover_example/","page":"Grover example","title":"Grover example","text":"mbqc_outcome = run_mbqc(para)\nubqc_outcome = run_ubqc(para)\nvbqc_outcome = run_verification_simulator(TrustworthyServer(),Verbose(),para)","category":"page"},{"location":"user/grover_example/#Noisy-models-in-verification","page":"Grover example","title":"Noisy models in verification","text":"","category":"section"},{"location":"user/grover_example/","page":"Grover example","title":"Grover example","text":"Set a scaling factor to ensure noise is not randomly chosen above threshold.","category":"page"},{"location":"user/grover_example/","page":"Grover example","title":"Grover example","text":"p_scale = 0.1","category":"page"},{"location":"user/grover_example/#Damping-noise","page":"Grover example","title":"Damping noise","text":"","category":"section"},{"location":"user/grover_example/","page":"Grover example","title":"Grover example","text":"# Damping\np = [p_scale*rand() for i in vertices(para[:graph])]\nmodel = Damping(Quest(),SingleQubit(),p)\nserver = NoisyServer(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/grover_example/#Dephasing-noise","page":"Grover example","title":"Dephasing noise","text":"","category":"section"},{"location":"user/grover_example/","page":"Grover example","title":"Grover example","text":"# Dephasing\np = [p_scale*rand() for i in vertices(para[:graph])]\nmodel = Dephasing(Quest(),SingleQubit(),p)\nserver = NoisyServer(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/grover_example/#Depolarising-noise","page":"Grover example","title":"Depolarising noise","text":"","category":"section"},{"location":"user/grover_example/","page":"Grover example","title":"Grover example","text":"# Depolarising\np = [p_scale*rand() for i in vertices(para[:graph])]\nmodel = Depolarising(Quest(),SingleQubit(),p)\nserver = NoisyServer(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/grover_example/#Pauli-noise","page":"Grover example","title":"Pauli noise","text":"","category":"section"},{"location":"user/grover_example/","page":"Grover example","title":"Grover example","text":"# Pauli\np_xyz(p_scale) = p_scale .* [rand(),rand(),rand()]\np = [p_xyz(p_scale) for i in vertices(para[:graph])]\nmodel = Pauli(Quest(),SingleQubit(),p)\nserver = NoisyServer(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/grover_example/#Vector-of-noise-models","page":"Grover example","title":"Vector of noise models","text":"","category":"section"},{"location":"user/grover_example/","page":"Grover example","title":"Grover example","text":"# Vector of noise models\nmodel_vec = [Damping,Dephasing,Depolarising,Pauli]\np_damp = [p_scale*rand() for i in vertices(para[:graph])]\np_deph = [p_scale*rand() for i in vertices(para[:graph])]\np_depo = [p_scale*rand() for i in vertices(para[:graph])]\np_pauli = [p_xyz(p_scale) for i in vertices(para[:graph])]\nprob_vec = [p_damp,p_deph,p_depo,p_pauli]\n\nmodels = Vector{NoiseModels}()\nfor m in eachindex(model_vec)\n    push!(models,model_vec[m](Quest(),SingleQubit(),prob_vec[m]))\nend\nserver = NoisyServer(models)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"references/api/#Function-API","page":"API","title":"Function API","text":"","category":"section"},{"location":"references/api/","page":"API","title":"API","text":"Documention generated automatically with @audotdocs. ","category":"page"},{"location":"references/api/","page":"API","title":"API","text":"Docs for package","category":"page"},{"location":"references/api/","page":"API","title":"API","text":"Modules = [VeriQuEST]\nOrder   = [:type, :constant, :macro, :function,]","category":"page"},{"location":"references/api/#VeriQuEST.Abort","page":"API","title":"VeriQuEST.Abort","text":"Abort\n\nA structure representing an aborted or unsuccessful result or status.\n\nExamples\n\nabort_result = Abort()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.AdjacencyList","page":"API","title":"VeriQuEST.AdjacencyList","text":"AdjacencyList\n\nA structure representing an adjacency list.\n\nExamples\n\nadjacency_list = AdjacencyList()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.BackwardFlow","page":"API","title":"VeriQuEST.BackwardFlow","text":"BackwardFlow\n\nA structure representing a backward flow in the system.\n\nExamples\n\nbackward_flow = BackwardFlow()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.BasisAngle","page":"API","title":"VeriQuEST.BasisAngle","text":"BasisAngle\n\nA structure representing the basis angle added to qubit initialization.\n\nExamples\n\nbasis_angle = BasisAngle()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.Client","page":"API","title":"VeriQuEST.Client","text":"Client\n\nA structure representing a client in the system. Currently, it has no fields.\n\nExamples\n\nclient = Client()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.ClusterState","page":"API","title":"VeriQuEST.ClusterState","text":"ClusterState\n\nA struct representing the cluster state in the MBQC framework.\n\nDescription\n\nClusterState is a marker struct used to represent the cluster state in an MBQC computation. It can be used in combination with other data structures or algorithms specific to the cluster state model.\n\nExample\n\n# Declare cluster state\ncluster_state = ClusterState()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.ComputationQubit","page":"API","title":"VeriQuEST.ComputationQubit","text":"ComputationQubit\n\nA structure representing a qubit used in computation.\n\nExamples\n\ncomputation_qubit = ComputationQubit()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.ComputationRound","page":"API","title":"VeriQuEST.ComputationRound","text":"ComputationRound\n\nA structure representing a round of quantum computation.\n\nExamples\n\ncomputation_round = ComputationRound()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.Damping","page":"API","title":"VeriQuEST.Damping","text":"mutable struct Damping <: NoiseModels\n\nA struct representing a damping noise model for a single qubit.\n\nFields\n\nbackend: The backend used for simulation.\ntype: The type of noise model (SingleQubit).\nprob: The probability of damping, can be a single value or a vector.\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.DensityMatrices","page":"API","title":"VeriQuEST.DensityMatrices","text":"DensityMatrices\n\nA type to represent density matrices\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.DensityMatrix","page":"API","title":"VeriQuEST.DensityMatrix","text":"DensityMatrix\n\nA structure representing a density matrix in the system.\n\nExamples\n\ndensity_matrix = DensityMatrix()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.DensityMatrixMixtureParameters","page":"API","title":"VeriQuEST.DensityMatrixMixtureParameters","text":"mutable struct DensityMatrixMixtureParameters <: NoiseParameters\n\nThe DensityMatrixMixtureParameters struct represents the parameters for a density matrix mixture noise model. It is a mutable struct that holds two density matrices, ρ₁ and ρ₂.\n\nFields\n\nρ₁::Union{DensityMatrix,Qureg}: The first density matrix.\nρ₂::Union{DensityMatrix,Qureg}: The second density matrix.\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.Dephasing","page":"API","title":"VeriQuEST.Dephasing","text":"struct Dephasing <: NoiseModels\n\nDephasing noise model that represents noise caused by dephasing errors.\n\nFields\n\nbackend: The backend used for simulation.\ntype: The type of qubits affected by the noise. Can be SingleQubit or TwoQubits.\nprob: The probability of dephasing error. Can be a single value or a vector of probabilities.\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.Depolarising","page":"API","title":"VeriQuEST.Depolarising","text":"mutable struct Depolarising <: NoiseModels\n\nA struct representing a depolarizing noise model.\n\nFields\n\nbackend: The backend used for the noise model.\ntype: The type of qubits affected by the noise model.\nprob: The probability of depolarization, can be a single value or a vector.\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.DimensionMismatchDensityMatrices","page":"API","title":"VeriQuEST.DimensionMismatchDensityMatrices","text":"DimensionMismatchDensityMatrices\n\nA type to represent an error when density matrices do not have the same dimensions\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.DummyQubit","page":"API","title":"VeriQuEST.DummyQubit","text":"DummyQubit\n\nA structure representing a dummy qubit.\n\nExamples\n\ndummy_qubit = DummyQubit()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.DummyQubitZeroOneInitialisationError","page":"API","title":"VeriQuEST.DummyQubitZeroOneInitialisationError","text":"DummyQubitZeroOneInitialisationError\n\nA structure representing an error in the initialisation of a dummy qubit to 0 or 1.\n\nExamples\n\nerror = DummyQubitZeroOneInitialisationError()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.ExceededNumKrausOperators","page":"API","title":"VeriQuEST.ExceededNumKrausOperators","text":"ExceededNumKrausOperators\n\nA type to represent an error when more Kraus operators were presented than allowed\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.ForwardFlow","page":"API","title":"VeriQuEST.ForwardFlow","text":"ForwardFlow\n\nA structure representing a forward flow in the system.\n\nExamples\n\nforward_flow = ForwardFlow()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.FunctionNotMeantToBeUsed","page":"API","title":"VeriQuEST.FunctionNotMeantToBeUsed","text":"FunctionNotMeantToBeUsed\n\nA structure representing a function that is not intended to be used.\n\nExamples\n\nnot_meant_to_be_used = FunctionNotMeantToBeUsed()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.InherentBoundedError","page":"API","title":"VeriQuEST.InherentBoundedError","text":"InherentBoundedError\n\nA structure representing an inherent bounded error with parameter p, 0  p  1.\n\nExamples\n\nerror = InherentBoundedError(p)\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.InputQubits","page":"API","title":"VeriQuEST.InputQubits","text":"InputQubits\n\nA struct representing input qubits in the MBQC framework.\n\nDescription\n\nInputQubits is a marker struct used to indicate the presence of input qubits in an MBQC computation. It is typically used in combination with other data structures or algorithms to handle input qubits in the computation.\n\nExample\n\n# Declare input qubits\ninput_qubits = InputQubits()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.Kraus","page":"API","title":"VeriQuEST.Kraus","text":"struct Kraus <: NoiseModels\n\nA struct representing a noise model using Kraus operators.\n\nFields\n\nbackend: The backend used for the noise model.\ntype: The type of noise model, which can be SingleQubit, TwoQubits, or MultipleQubits.\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.KrausMapNoiseParameters","page":"API","title":"VeriQuEST.KrausMapNoiseParameters","text":"struct KrausMapNoiseParameters <: NoiseParameters\n\nThe KrausMapNoiseParameters struct represents the noise parameters for a Kraus map noise model.\n\nFields:\n\ntrace: Union{TracePreserving,NotTracePreserving} - Specifies whether the noise is trace preserving or not.\nρ: Union{DensityMatrix,Qureg} - The density matrix or quantum register representing the initial state.\nq: Union{Nothing,Vector{Int64},Int64,Vector{Int32},Int32} - The indices of the qubits affected by the noise.\nmat: Matrix{ComplexF64} - The matrix representation of the Kraus operators.\nnum_ops: Union{Int32,Int64} - The number of Kraus operators.\nnum_qubits: Union{Nothing,Int64} - The number of qubits in the system.\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.MBQC","page":"API","title":"VeriQuEST.MBQC","text":"MBQC\n\nA structure representing the concept of Measurement-Based Quantum Computation (MBQC).\n\nExamples\n\nmbqc = MBQC()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.MBQCAngles","page":"API","title":"VeriQuEST.MBQCAngles","text":"MBQCAngles(angles)\n\nStruct representing the angles associated to the graph. The number of angles will be the same as the vertices in the graph.\n\nParameters\n\nangles: A listed set of values, as long as the angles are indexable in the same ways that the vertices are.\n\nExample\n\njulia> angles = [π,π/4,5π/4,7π/4]\njulia> mbqc_angles = MBQCAngles(angles) \n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.MBQCColouringSet","page":"API","title":"VeriQuEST.MBQCColouringSet","text":"MBQCColouringSet\n\nA structure representing a colouring set in the Measurement-Based Quantum Computing (MBQC) model. It contains two fields: computation_round and test_round.\n\nFields\n\ncomputation_round: Represents the computation round in the MBQC model.\ntest_round: Represents the test round in the MBQC model.\n\nExamples\n\nmbqc_colouring_set = MBQCColouringSet(computation_round, test_round)\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.MBQCFlow","page":"API","title":"VeriQuEST.MBQCFlow","text":"MBQCFlow(forward_flow, backward_flow)\n\nStruct representing flow in MBQC.\n\nDefinition of Flow\n\nforward_flow, f: Oᶜ → Iᶜ is a mapping v ↦ f(v) with an inverse f⁻¹(v) ↦ v, with partial order \"≤\". The partial order is said to map the present to the future or the present to the past.\n(a) v ∼ f(v), where \"∼\" defines the neighbourhood N(f(v)) and v has set membership.\n(b) v ≤ f(v)\n(c) w ∼ f(v), then ∀ v, v ≤ w\n\nExample\n\nOne dimensional lattice, the \"path graph\", where a vertex is represented as \"()\" and an edge is represented as \"–-\".\nLet i be the index of each vertex so that i = {1, 2, 3, 4} and\np := (1)---(2)---(3)---(4)\nf(i) := i + 1\nf⁻¹(i) := i - 1\nf([1, 2, 3]) = [2, 3, 4], since 4 has no future, there is no 4 + 1 answer.\nf⁻¹([2, 3, 4]) = [1, 2, 3], since 1 has no past, there is no 1 - 1 answer.\n\nParameters\n\nforward_flow: A mapping to take an input vertex and return the output vertex such that the definitions of flow hold. The forward flow function can be any container that takes a vertex index as input and outputs a new vertex index.\nbackward_flow: A mapping to take an output vertex and return the input vertex. The backward flow function maps the inverse of the forward flow.\n\nExample\n\n# Define forward and backward flow functions\nforward_flow(io) = io[2]\nbackward_flow(io) = io[1]\n\n# Create an MBQCFlow\nmbqc_flow = MBQCFlow(forward_flow, backward_flow)\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.MBQCGraph","page":"API","title":"VeriQuEST.MBQCGraph","text":"MBQCGraph(graph,input,output)\n\nStruct representing the graph used in the MBQC. Container holds the graph as well as the input and output sets.\n\nParameters\n\ngraph: Any graph suitable for MBQC\ninput: has type MBQCInput\noutput: had type MBQCOutput\n\nExample\n\njulia> using Graphs # use using Pkg; Pkg.add(\"Graphs\") is not installede\njulia> graph = Graphs.grid([1,4]) # 1D cluster graph (path graph) on 4 vertices\njulia> indices,values = (1),(0)\njulia> input  = MBQCInput(indices,values)\njulia> indices = (4)\njulia> output  = MBQCOutput(indices)\njulia> mbqc_graph = MBQCGraph(graph,input,output)\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.MBQCInput","page":"API","title":"VeriQuEST.MBQCInput","text":"MBQCInput(indices,values)\n\nStruct representing an input set into the graph, can be empty\n\nParameters\n\nindices: has type Tuple on normally integers (whole numbers 1 to N) and correspond to vertices in a graph.\nvalues: has type Tuple, can be any type\n\nExample\n\njulia> indices = (1,2,3,4)\njulia> values = (0,1,1,0) #Computational basis outcomes\njulia> mbqc_input = MBQCInput(indices,values)\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.MBQCMeasurementOutcomes","page":"API","title":"VeriQuEST.MBQCMeasurementOutcomes","text":"MBQCMeasurementOutcomes(outcomes)\n\nStruct representing measurement outcomes in MBQC.\n\nParameter\n\noutcomes: An array or container representing the measurement outcomes.\n\nExample\n\n# Define measurement outcomes\noutcomes = [0, 1, 1, 0]\n\n# Create an MBQCMeasurementOutcomes\nmeasurement_outcomes = MBQCMeasurementOutcomes(outcomes)\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.MBQCOutput","page":"API","title":"VeriQuEST.MBQCOutput","text":"MBQCOutput(indices)\n\nStruct representing an output set into the graph, can be empty.\n\nParameters\n\nindices: has type Tuple on normally integers (whole numbers 1 to N) and correspond to the vertices in a graph.\n\nExample\n\njulia> indices = (10,11,12)\njulia> mbqc_output = MBQCOutput(indices)\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.MBQCResourceState","page":"API","title":"VeriQuEST.MBQCResourceState","text":"MBQCResourceState(graph, flow, angles)\n\nStruct representing a resource state in MBQC.\n\nParameters\n\ngraph: An instance of MBQCGraph representing the underlying graph structure.\nflow: An instance of MBQCFlow representing the flow in the resource state.\nangles: An instance of MBQCAngles representing the angles associated with each vertex.\n\nExample\n\n# Create an MBQCGraph\ngraph = MBQCGraph([1, 2, 3], [(1, 2), (2, 3)])\n\n# Create an MBQCFlow\nflow = MBQCFlow((1, 2) => 2, (2, 3) => 3)\n\n# Create an MBQCAngles\nangles = MBQCAngles([π/2, π/4, π/3])\n\n# Create an MBQCResourceState\nresource_state = MBQCResourceState(graph, flow, angles)\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.MaliciousServer","page":"API","title":"VeriQuEST.MaliciousServer","text":"MaliciousServer\n\nA type representing a server that is malicious. This type is used to model a server that behaves in a way that is not consistent with the protocol. This type is used to model malicious behaviour in the client-server model.\n\nExamples\n\nMaliciousServer()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.MeasurementOutcome","page":"API","title":"VeriQuEST.MeasurementOutcome","text":"MeasurementOutcome\n\nA structure representing the outcome of a quantum measurement.\n\nExamples\n\nmeasurement_outcome = MeasurementOutcome()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.MixtureDensityMatrices","page":"API","title":"VeriQuEST.MixtureDensityMatrices","text":"mutable struct MixtureDensityMatrices <: NoiseModels\n\nA mutable struct representing a mixture of density matrices noise model.\n\nFields\n\nbackend: The backend used for the noise model.\ntype: The type of density matrices.\nprob: The probability distribution of the mixture.\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.MultipleQubits","page":"API","title":"VeriQuEST.MultipleQubits","text":"MultipleQubits\n\nA type to represent multiple qubits\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.NoInputQubits","page":"API","title":"VeriQuEST.NoInputQubits","text":"NoInputQubits\n\nA struct representing the absence of input qubits in the MBQC framework.\n\nDescription\n\nNoInputQubits is a marker struct used to indicate the absence of input qubits in an MBQC computation. It can be used as a flag or placeholder to handle scenarios where there are no input qubits in the computation.\n\nExample\n\n# Declare absence of input qubits\nno_input_qubits = NoInputQubits()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.NoNoise","page":"API","title":"VeriQuEST.NoNoise","text":"struct NoNoise <: NoiseModels\n\nA struct representing a noise model with no noise.\n\nFields\n\nbackend: The backend used for the noise model.\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.NoNoiseParameters","page":"API","title":"VeriQuEST.NoNoiseParameters","text":"NoNoiseParameters\n\nAn abstract type representing the parameters for no noise.\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.NoPhase","page":"API","title":"VeriQuEST.NoPhase","text":"NoPhase\n\nA structure representing the absence of a phase in the qubit initialization.\n\nExamples\n\nno_phase = NoPhase()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.NoiseModel","page":"API","title":"VeriQuEST.NoiseModel","text":"mutable struct NoiseModel <: NoiseModels\n\nA mutable struct representing a noise model.\n\nFields\n\nmodel: The noise model.\nparams: The parameters of the noise model.\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.NoiseModelParams","page":"API","title":"VeriQuEST.NoiseModelParams","text":"mutable struct NoiseModelParams <: NoiseParameters\n\nNoise model parameters for representing noise in a system.\n\nFields\n\nprob::Union{Float64,Float64,Vector{Float64},Vector{Float64}}: The probability of noise occurring.\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.NoiseModels","page":"API","title":"VeriQuEST.NoiseModels","text":"NoiseModels\n\nAn abstract type representing different noise models. Specific noise models should subtype this.\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.NoiseParameters","page":"API","title":"VeriQuEST.NoiseParameters","text":"NoiseParameters\n\nAn abstract type representing the parameters for noise.\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.NoisyClient","page":"API","title":"VeriQuEST.NoisyClient","text":"    NoisyClient(noise_model::Union{Vector{NoiseModel}, NoiseModel})\n\nFor MBQC only. A structure representing a client that operates under some noise model. May be buggy.\n\nFields\n\nnoise_model::Union{Vector{NoiseModel}, NoiseModel}: The noise model under which the client operates.    This can be a single NoiseModel or a vector of NoiseModels.\n\nExamples\n\nnoise_model = NoiseModel()\nclient = NoisyClient(noise_model)\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.NoisyServer","page":"API","title":"VeriQuEST.NoisyServer","text":"mutable struct NoisyServer\n\nA struct representing a noisy server.\n\nFields\n\nnoise_model: The noise model used by the server. It can be either a single NoiseModels object or a vector of NoiseModels objects.\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.NotTracePreserving","page":"API","title":"VeriQuEST.NotTracePreserving","text":"NotTracePreserving\n\nA type to represent a non trace preserving\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.Ok","page":"API","title":"VeriQuEST.Ok","text":"Ok\n\nA structure representing a successful result or status.\n\nExamples\n\nok_result = Ok()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.OnlySingleQubitNoiseInUseError","page":"API","title":"VeriQuEST.OnlySingleQubitNoiseInUseError","text":"OnlySingleQubitNoiseInUseError\n\nA type to represent an error when two qubit or multiple qubit noise is not tested\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.Pauli","page":"API","title":"VeriQuEST.Pauli","text":"mutable struct Pauli <: NoiseModels\n\nThe Pauli struct represents a noise model for a single qubit. It contains the following fields:\n\nbackend: The backend used for simulation.\ntype: The type of noise model (SingleQubit).\nprob: The probability of each Pauli error. It can be a single value, a vector of values, or a matrix of values.\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.Phase","page":"API","title":"VeriQuEST.Phase","text":"Phase\n\nA structure indicating phase is added to qunit initialisation\n\nExamples\n\nphase = Phase()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.ProbabilityExceedsFifteenSixteensError","page":"API","title":"VeriQuEST.ProbabilityExceedsFifteenSixteensError","text":"ProbabilityExceedsFifteenSixteensError\n\nA type to represent an error when a probability exceeds 15/16\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.ProbabilityExceedsNoErrorExceeded","page":"API","title":"VeriQuEST.ProbabilityExceedsNoErrorExceeded","text":"ProbabilityExceedsNoErrorExceeded\n\nA type to represent an error when a probability exceeds no error\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.ProbabilityExceedsOneError","page":"API","title":"VeriQuEST.ProbabilityExceedsOneError","text":"ProbabilityExceedsOneError\n\nA type to represent an error when a probability exceeds 1\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.ProbabilityExceedsOneHalfError","page":"API","title":"VeriQuEST.ProbabilityExceedsOneHalfError","text":"ProbabilityExceedsOneHalfError\n\nA type to represent an error when a probability exceeds 1/2\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.ProbabilityExceedsThreeQuartersError","page":"API","title":"VeriQuEST.ProbabilityExceedsThreeQuartersError","text":"ProbabilityExceedsThreeQuartersError\n\nA type to represent an error when a probability exceeds 3/4\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.ProbabilityLessThanZeroError","page":"API","title":"VeriQuEST.ProbabilityLessThanZeroError","text":"ProbabilityLessThanZeroError\n\nA type to represent an error when a probability is less than 0\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.QubitFloatPhaseInitialisationError","page":"API","title":"VeriQuEST.QubitFloatPhaseInitialisationError","text":"QubitFloatPhaseInitialisationError\n\nA structure representing an error in the initialisation of a qubit's float phase.\n\nExamples\n\nerror = QubitFloatPhaseInitialisationError()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.QubitInitialState","page":"API","title":"VeriQuEST.QubitInitialState","text":"QubitInitialState\n\nA structure indicating the initial state of a qubit during qubit initialization.\n\nExamples\n\nqubit_initial_state = QubitInitialState()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.QubitNoiseParameters","page":"API","title":"VeriQuEST.QubitNoiseParameters","text":"mutable struct QubitNoiseParameters <: NoiseParameters\n\nQubit noise parameters for a quantum system.\n\nFields\n\nρ::Union{DensityMatrix,Qureg}: The density matrix or quantum register representing the state of the qubits.\nq::Union{Nothing,Vector{Int64},Int64,Vector{Int32},Int32}: The indices of the qubits affected by the noise.\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.Quest","page":"API","title":"VeriQuEST.Quest","text":"Quest\n\nA type to represent the QuEST library\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.SecretAngles","page":"API","title":"VeriQuEST.SecretAngles","text":"SecretAngles\n\nA structure representing secret angles used in the system.\n\nExamples\n\nsecret_angles = SecretAngles()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.Server","page":"API","title":"VeriQuEST.Server","text":"Server\n\nA structure representing a server in the system. Currently, it has no fields.\n\nExamples\n\nserver = Server()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.SingleQubit","page":"API","title":"VeriQuEST.SingleQubit","text":"SingleQubit\n\nA type to represent a single qubit\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.StateVector","page":"API","title":"VeriQuEST.StateVector","text":"StateVector\n\nA structure representing a state vector in the system.\n\nExamples\n\nstate_vector = StateVector()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.Terse","page":"API","title":"VeriQuEST.Terse","text":"Terse\n\nA structure representing a terse or concise mode.\n\nExamples\n\nterse_mode = Terse()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.TestRound","page":"API","title":"VeriQuEST.TestRound","text":"TestRound\n\nA structure representing a round of testing.\n\nExamples\n\ntest_round = TestRound()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.TracePreserving","page":"API","title":"VeriQuEST.TracePreserving","text":"TracePreserving\n\nA type to represent a trace preserving map\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.TrapFail","page":"API","title":"VeriQuEST.TrapFail","text":"TrapFail\n\nA structure representing a failed outcome in a trap scenario.\n\nExamples\n\ntrap_fail_result = TrapFail()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.TrapPass","page":"API","title":"VeriQuEST.TrapPass","text":"TrapPass\n\nA structure representing a successful pass in a trap scenario.\n\nExamples\n\ntrap_pass_result = TrapPass()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.TrapQubit","page":"API","title":"VeriQuEST.TrapQubit","text":"TrapQubit\n\nA structure representing a qubit used in a trap.\n\nExamples\n\ntrap_qubit = TrapQubit()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.TrustworthyServer","page":"API","title":"VeriQuEST.TrustworthyServer","text":"TrustworthyServer\n\nA structure representing a trustworthy server in the system. Currently, it has no fields.\n\nExamples\n\ntrustworthy_server = TrustworthyServer()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.TwoQubits","page":"API","title":"VeriQuEST.TwoQubits","text":"TwoQubits\n\nA type to represent two qubits\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.UntestedKrausFunction","page":"API","title":"VeriQuEST.UntestedKrausFunction","text":"UntestedKrausFunction\n\nA type to represent a warning when a Kraus operator is not tested\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.Verbose","page":"API","title":"VeriQuEST.Verbose","text":"Verbose\n\nA structure representing a verbose or detailed mode.\n\nExamples\n\nverbose_mode = Verbose()\n\n\n\n\n\n","category":"type"},{"location":"references/api/#VeriQuEST.MetaGraph-Tuple{Client, MBQCResourceState}","page":"API","title":"VeriQuEST.MetaGraph","text":"MetaGraph(::Client, resource::MBQCResourceState)\n\nThis function creates a MetaGraph from a given MBQCResourceState. It extracts the graph from the resource state and wraps it in a MetaGraph.\n\nArguments\n\nclient::Client: The client object.\nresource::MBQCResourceState: The MBQC resource state containing the graph.\n\nExamples\n\njulia client = Client() resource = MBQCResourceState(graph) MetaGraph(client, resource)`\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.add_bit_flip!-Tuple{Quest, SingleQubit, Any, Any, Any}","page":"API","title":"VeriQuEST.add_bit_flip!","text":"mixBitFlip(ρ::Array{Complex{Float64},2},q::Int64,p::Float64)\n\nMixes a bit flip noise model to a density matrix.\n\nArguments\n\nρ::QuEST density matrix: The density matrix to apply the noise to\nq::Int64: The qubit to apply the noise to\np::Float64: The probability of the noise\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.add_correction_vertices!-Tuple{Client, Any, MBQCResourceState}","page":"API","title":"VeriQuEST.add_correction_vertices!","text":"add_correction_vertices!(::Client, mg, resource::MBQCResourceState)\n\nThis function adds correction vertices to the meta graph for a client in the MBQC model.  It iterates over each vertex in the resource, gets the correction vertices for each,  and sets these as properties in the meta graph.\n\nArguments\n\n::Client: The Client object.\nmg: The MetaGraph to which the properties will be added.\nresource::MBQCResourceState: The resource containing the graph and its coloring.\n\nReturns\n\nThe updated MetaGraph.\n\nExamples\n\nclient = Client()\nresource = MBQCResourceState(graph)\nmg = MetaGraphs.MetaGraph(resource.graph.graph)\nadd_correction_vertices!(client, mg, resource)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.add_damping!-Tuple{Quest, SingleQubit, Any, Any, Any}","page":"API","title":"VeriQuEST.add_damping!","text":"mixDamping(ρ::Array{Complex{Float64},2},q::Int64,p::Float64)\n\nMixes a damping noise model to a density matrix.\n\nArguments\n\nρ::QuEST density matrix: The density matrix to apply the noise to\nq::Int64: The qubit to apply the noise to\np::Float64: The probability of the noise\n\nExamples\n\n```julia     numqubits = 1 q = 1 p = 0.3 quantumenv = createQuESTEnv() ρ = createDensityQureg(numqubits, quantumenv) add_damping!(Quest(),SingleQubit(),ρ,q,p)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.add_dephasing!-Tuple{Quest, SingleQubit, Any, Any, Any}","page":"API","title":"VeriQuEST.add_dephasing!","text":"add_dephasing!(::Quest,::SingleQubit,ρ,q,p)\n\nAdds a dephasing noise model to a density matrix.\n\nArguments\n\n::Quest: Indicates that this function is used in the context of a Quest environment.\n::SingleQubit: Indicates that the noise is applied to a single qubit.\nρ::QuEST density matrix: The density matrix to apply the noise to.\nq::Int64: The qubit to apply the noise to.\np::Float64: The probability of the noise.\n\nExamples\n\nnum_qubits = 1\nq = 1\np = 0.3\nquantum_env = createQuESTEnv()\nρ = createDensityQureg(num_qubits, quantum_env)\nadd_dephasing!(Quest(),SingleQubit(),ρ,q,p) \n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.add_dephasing!-Tuple{Quest, TwoQubits, Any, Any, Any}","page":"API","title":"VeriQuEST.add_dephasing!","text":"add_dephasing!(::Quest,::TwoQubits,ρ,q,p)\n\nAdds a dephasing noise model to a density matrix for two qubits.\n\nArguments\n\n::Quest: Indicates that this function is used in the context of a Quest environment.\n::TwoQubits: Indicates that the noise is applied to two qubits.\nρ::QuEST density matrix: The density matrix to apply the noise to.\nq::Tuple{Int64, Int64}: The qubits to apply the noise to.\np::Float64: The probability of the noise.\n\nExamples\n\nnum_qubits = 2\nq = (1, 2)\np = 0.3\nquantum_env = createQuESTEnv()\nρ = createDensityQureg(num_qubits, quantum_env)\nadd_dephasing!(Quest(),TwoQubits(),ρ,q,p)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.add_depolarising!-Tuple{Quest, SingleQubit, Any, Any, Any}","page":"API","title":"VeriQuEST.add_depolarising!","text":"add_depolarising!(::Quest,::SingleQubit,ρ,q,p)\n\nAdds a depolarising noise model to a density matrix for a single qubit.\n\nArguments\n\n::Quest: Indicates that this function is used in the context of a Quest environment.\n::SingleQubit: Indicates that the noise is applied to a single qubit.\nρ::QuEST density matrix: The density matrix to apply the noise to.\nq::Int64: The qubit to apply the noise to.\np::Float64: The probability of the noise.\n\nExamples\n\nnum_qubits = 1\nq = 1\np = 0.3\nquantum_env = createQuESTEnv()\nρ = createDensityQureg(num_qubits, quantum_env)\nadd_depolarising!(Quest(),SingleQubit(),ρ,q,p)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.add_depolarising!-Tuple{Quest, TwoQubits, Any, Any, Any}","page":"API","title":"VeriQuEST.add_depolarising!","text":"add_depolarising!(::Quest,::TwoQubits,ρ,q,p)\n\nAdds a depolarising noise model to a density matrix for two qubits.\n\nArguments\n\n::Quest: Indicates that this function is used in the context of a Quest environment.\n::TwoQubits: Indicates that the noise is applied to two qubits.\nρ::QuEST density matrix: The density matrix to apply the noise to.\nq::Tuple{Int64, Int64}: The qubits to apply the noise to.\np::Float64: The probability of the noise.\n\nExamples\n\nnum_qubits = 2\nq = (1, 2)\np = 0.3\nquantum_env = createQuESTEnv()\nρ = createDensityQureg(num_qubits, quantum_env)\nadd_depolarising!(Quest(),TwoQubits(),ρ,q,p)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.add_flow_vertex!-Tuple{Client, Any, MBQCResourceState, Union{BackwardFlow, ForwardFlow}}","page":"API","title":"VeriQuEST.add_flow_vertex!","text":"add_flow_vertex!(::Client, mg, resource::MBQCResourceState, flow_type::Union{ForwardFlow,BackwardFlow})\n\nThis function adds a flow vertex to the meta graph for a client in the MBQC model.  It first converts the flow type to a symbol, then iterates over each vertex in the resource.  For each vertex, it gets the verified flow output and sets this as a property in the meta graph.\n\nArguments\n\n::Client: The Client object.\nmg: The MetaGraph to which the properties will be added.\nresource::MBQCResourceState: The resource containing the graph and its coloring.\nflow_type::Union{ForwardFlow,BackwardFlow}: The flow type to be added.\n\nReturns\n\nThe updated MetaGraph.\n\nExamples\n\nclient = Client()\nresource = MBQCResourceState(graph)\nmg = MetaGraphs.MetaGraph(resource.graph.graph)\nflow_type = ForwardFlow()\nadd_flow_vertex!(client, mg, resource, flow_type)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.add_flow_vertex!-Tuple{Client, Any, MBQCResourceState}","page":"API","title":"VeriQuEST.add_flow_vertex!","text":"add_flow_vertex!(::Client, mg, resource::MBQCResourceState)\n\nThis function adds both forward and backward flow vertices to the meta graph for a client in the MBQC model.  It calls the add_flow_vertex! function twice, once with ForwardFlow and once with BackwardFlow.\n\nArguments\n\n::Client: The Client object.\nmg: The MetaGraph to which the properties will be added.\nresource::MBQCResourceState: The resource containing the graph and its coloring.\n\nReturns\n\nThe updated MetaGraph.\n\nExamples\n\nclient = Client()\nresource = MBQCResourceState(graph)\nmg = MetaGraphs.MetaGraph(resource.graph.graph)\nadd_flow_vertex!(client, mg, resource)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.add_noise!-Tuple{Client, NoiseModel}","page":"API","title":"VeriQuEST.add_noise!","text":"add_noise!(client::Client, noise_model::NoiseModel)\n\nThis function adds noise to a quantum system according to the specified noise model. It calls the add_noise! function  with a new client and the given noise model as arguments.\n\nArguments\n\nclient::Client: The client for which the noise is being added.\nnoise_model::NoiseModel: The noise model to be used.\n\nExamples\n\nclient = Client()\nnoise_model = NoiseModel()\nadd_noise!(client, noise_model)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.add_noise!-Tuple{Client, Union{Damping, Dephasing, Depolarising, Pauli}, QubitNoiseParameters}","page":"API","title":"VeriQuEST.add_noise!","text":"add_noise!(client::Client, model::Union{Damping,Dephasing,Depolarising,Pauli}, params::QubitNoiseParameters)\n\nThis function adds noise to a quantum system. The noise model can be one of Damping, Dephasing, Depolarising, or Pauli.  The function throws an error if the noise type is not SingleQubit. It then iterates over the range of qubits represented  in the backend and adds noise to each qubit according to the specified model and parameters.\n\nArguments\n\nclient::Client: The client for which the noise is being added.\nmodel::Union{Damping,Dephasing,Depolarising,Pauli}: The noise model to be used.\nparams::QubitNoiseParameters: The parameters for the noise model.\n\nExamples\n\nclient = Client()\nmodel = Damping()\nparams = QubitNoiseParameters(SingleQubit(), backend)\nadd_noise!(client, model, params)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.add_noise!-Tuple{Kraus, KrausMapNoiseParameters}","page":"API","title":"VeriQuEST.add_noise!","text":"add_noise!(model::Kraus, params::KrausMapNoiseParameters)\n\nAdd noise to a quantum model using a specified noise function.\n\nArguments\n\nmodel::Kraus: The quantum model to which noise will be added.\nparams::KrausMapNoiseParameters: The parameters specifying the noise model.\n\n```\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.add_noise!-Tuple{MixtureDensityMatrices, DensityMatrixMixtureParameters}","page":"API","title":"VeriQuEST.add_noise!","text":"add_noise!(model::MixtureDensityMatrices, params::DensityMatrixMixtureParameters)\n\nAdd noise to the given model using the specified params.\n\nArguments\n\nmodel::MixtureDensityMatrices: The mixture density matrices model.\nparams::DensityMatrixMixtureParameters: The parameters for the density matrix mixture.\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.add_noise!-Tuple{NoNoise, NoNoiseParameters}","page":"API","title":"VeriQuEST.add_noise!","text":"add_noise!(::NoNoise, params::NoNoiseParameters)\n\nAdd noise to the given parameters.\n\nArguments\n\n::NoNoise: A type representing no noise.\nparams::NoNoiseParameters: The parameters to add noise to.\n\nReturns\n\nparams.ρ: The noise parameter.\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.add_noise!-Tuple{NoisyServer, Any}","page":"API","title":"VeriQuEST.add_noise!","text":"add_noise!(server::NoisyServer, server_qureg)\n\nAdds noise to a quantum register (server_qureg) based on the noise model(s) defined in a NoisyServer. The function supports both single and multiple noise models. For each noise model, it retrieves the parameters using get_noise_model_params and applies the noise to each qubit in the quantum register.\n\nArguments\n\nserver::NoisyServer: A NoisyServer instance that contains the noise model(s) to be applied.\nserver_qureg: The quantum register to which the noise will be applied.\n\nExamples\n\nserver = NoisyServer(noise_model)\nserver_qureg = QuantumRegister(3)\nadd_noise!(server, server_qureg)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.add_noise!-Tuple{Union{Damping, Dephasing, Depolarising, Pauli}, QubitNoiseParameters}","page":"API","title":"VeriQuEST.add_noise!","text":"add_noise!(model::Union{Damping,Dephasing,Depolarising,Pauli}, params::QubitNoiseParameters)\n\nAdd noise to a quantum model based on the given noise parameters.\n\nArguments\n\nmodel::Union{Damping,Dephasing,Depolarising,Pauli}: The quantum model to add noise to.\nparams::QubitNoiseParameters: The noise parameters specifying the type and strength of the noise.\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.add_output_qubits!-Tuple{Client, Any, MBQCResourceState}","page":"API","title":"VeriQuEST.add_output_qubits!","text":"add_output_qubits!(::Client, mg, resource::MBQCResourceState)\n\nThis function adds output qubits to the meta graph for a client in the MBQC model.  It retrieves the output indices from the resource graph and sets the :output_inds property of the meta graph to these indices.\n\nArguments\n\n::Client: The Client object.\nmg: The MetaGraph to which the property will be added.\nresource::MBQCResourceState: The resource containing the graph and its coloring.\n\nReturns\n\nThe updated MetaGraph.\n\nExamples\n\nclient = Client()\nresource = MBQCResourceState(graph)\nmg = MetaGraphs.MetaGraph(resource.graph.graph)\nadd_output_qubits!(client, mg, resource)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.add_pauli_noise!-Tuple{Quest, SingleQubit, Any, Any, Any}","page":"API","title":"VeriQuEST.add_pauli_noise!","text":"add_pauli_noise!(::Quest,::SingleQubit,ρ,q,p)\n\nAdds a Pauli noise model to a density matrix for a single qubit.\n\nArguments\n\n::Quest: Indicates that this function is used in the context of a Quest environment.\n::SingleQubit: Indicates that the noise is applied to a single qubit.\nρ::QuEST density matrix: The density matrix to apply the noise to.\nq::Int64: The qubit to apply the noise to.\np::Tuple{Float64, Float64, Float64}: The probabilities of the X, Y, and Z Pauli errors.\n\nExamples\n\nnum_qubits = 1\nq = 1\np = (0.1, 0.2, 0.3)\nquantum_env = createQuESTEnv()\nρ = createDensityQureg(num_qubits, quantum_env)\nadd_pauli_noise!(Quest(),SingleQubit(),ρ,q,p)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.add_round_type!-Tuple{Client, Any, Any}","page":"API","title":"VeriQuEST.add_round_type!","text":"add_round_type!(::Client, mg, round_type)\n\nThis function adds a round type to the meta graph for a client in the MBQC model.  It sets the :round_type property of the meta graph to the specified round type.\n\nArguments\n\n::Client: The Client object.\nmg: The MetaGraph to which the property will be added.\nround_type: The round type to be added to the meta graph.\n\nReturns\n\nThe updated MetaGraph.\n\nExamples\n\nclient = Client()\nmg = MetaGraphs.MetaGraph(graph)\nround_type = \"round1\"\nadd_round_type!(client, mg, round_type)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.apply_kraus_map!-Tuple{Quest, MultipleQubits, NotTracePreserving, Vararg{Any, 4}}","page":"API","title":"VeriQuEST.apply_kraus_map!","text":"apply_kraus_map!(::Quest,::MultipleQubits,::NotTracePreserving,ρ,q,complex_mat,num_ops)\n\nApplies a non-trace preserving Kraus map to a density matrix for multiple qubits.\n\nArguments\n\n::Quest: Indicates that this function is used in the context of a Quest environment.\n::MultipleQubits: Indicates that the operation is applied to multiple qubits.\n::NotTracePreserving: Indicates that the operation is not trace preserving.\nρ::QuEST density matrix: The density matrix to apply the operation to.\nq::Tuple{Int64, Int64}: The least significant qubit and the number of qubits.\ncomplex_mat::Array{ComplexF64, 3}: The array of Kraus operators.\nnum_ops::Int64: The number of Kraus operators.\n\nExamples\n\nnum_qubits = 3\nleas_sig_qubit = 1\nnum_ops = 8\ncomplex_mat = Array{ComplexF64, 3}(undef, 2, 2, num_ops)\nquantum_env = createQuESTEnv()\nρ = createDensityQureg(num_qubits, quantum_env)\napply_kraus_map!(Quest(),MultipleQubits(),NotTracePreserving(),ρ,(leas_sig_qubit,num_qubits),complex_mat,num_ops)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.apply_kraus_map!-Tuple{Quest, MultipleQubits, TracePreserving, Vararg{Any, 5}}","page":"API","title":"VeriQuEST.apply_kraus_map!","text":"apply_kraus_map!(::Quest,::MultipleQubits,::TracePreserving,ρ,leas_sig_qubit,num_qubits,complex_mat,num_ops)\n\nApplies a Kraus map to a density matrix for multiple qubits.\n\nArguments\n\n::Quest: Indicates that this function is used in the context of a Quest environment.\n::MultipleQubits: Indicates that the operation is applied to multiple qubits.\n::TracePreserving: Indicates that the operation is trace preserving.\nρ::QuEST density matrix: The density matrix to apply the operation to.\nleas_sig_qubit::Int64: The least significant qubit.\nnum_qubits::Int64: The number of qubits.\ncomplex_mat::Array{ComplexF64, 3}: The array of Kraus operators.\nnum_ops::Int64: The number of Kraus operators.\n\nExamples\n\nnum_qubits = 3\nleas_sig_qubit = 1\nnum_ops = 8\ncomplex_mat = Array{ComplexF64, 3}(undef, 2, 2, num_ops)\nquantum_env = createQuESTEnv()\nρ = createDensityQureg(num_qubits, quantum_env)\napply_kraus_map!(Quest(),MultipleQubits(),TracePreserving(),ρ,leas_sig_qubit,num_qubits,complex_mat,num_ops)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.apply_kraus_map!-Tuple{Quest, SingleQubit, NotTracePreserving, Vararg{Any, 4}}","page":"API","title":"VeriQuEST.apply_kraus_map!","text":"apply_kraus_map!(::Quest,::SingleQubit,::NotTracePreserving,ρ,q,complex_mat,num_ops)\n\nApplies a non-trace preserving Kraus map to a density matrix for a single qubit.\n\nArguments\n\n::Quest: Indicates that this function is used in the context of a Quest environment.\n::SingleQubit: Indicates that the operation is applied to a single qubit.\n::NotTracePreserving: Indicates that the operation is not trace preserving.\nρ::QuEST density matrix: The density matrix to apply the operation to.\nq::Int64: The qubit to apply the operation to.\ncomplex_mat::Array{ComplexF64, 3}: The array of Kraus operators.\nnum_ops::Int64: The number of Kraus operators.\n\nExamples\n\nnum_qubits = 1\nq = 1\nnum_ops = 2\ncomplex_mat = Array{ComplexF64, 3}(undef, 2, 2, num_ops)\nquantum_env = createQuESTEnv()\nρ = createDensityQureg(num_qubits, quantum_env)\napply_kraus_map!(Quest(),SingleQubit(),NotTracePreserving(),ρ,q,complex_mat,num_ops)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.apply_kraus_map!-Tuple{Quest, SingleQubit, TracePreserving, Vararg{Any, 4}}","page":"API","title":"VeriQuEST.apply_kraus_map!","text":"apply_kraus_map!(::Quest,::SingleQubit,::TracePreserving,ρ,q,complex_mat,num_ops)\n\nApplies a Kraus map to a density matrix for a single qubit.\n\nArguments\n\n::Quest: Indicates that this function is used in the context of a Quest environment.\n::SingleQubit: Indicates that the operation is applied to a single qubit.\n::TracePreserving: Indicates that the operation is trace preserving.\nρ::QuEST density matrix: The density matrix to apply the operation to.\nq::Int64: The qubit to apply the operation to.\ncomplex_mat::Array{ComplexF64, 3}: The array of Kraus operators.\nnum_ops::Int64: The number of Kraus operators.\n\nExamples\n\nnum_qubits = 1\nq = 1\nnum_ops = 2\ncomplex_mat = Array{ComplexF64, 3}(undef, 2, 2, num_ops)\nquantum_env = createQuESTEnv()\nρ = createDensityQureg(num_qubits, quantum_env)\napply_kraus_map!(Quest(),SingleQubit(),TracePreserving(),ρ,q,complex_mat,num_ops)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.apply_kraus_map!-Tuple{Quest, TwoQubits, NotTracePreserving, Vararg{Any, 4}}","page":"API","title":"VeriQuEST.apply_kraus_map!","text":"apply_kraus_map!(::Quest,::TwoQubits,::NotTracePreserving,ρ,q,complex_mat,num_ops)\n\nApplies a non-trace preserving Kraus map to a density matrix for two qubits.\n\nArguments\n\n::Quest: Indicates that this function is used in the context of a Quest environment.\n::TwoQubits: Indicates that the operation is applied to two qubits.\n::NotTracePreserving: Indicates that the operation is not trace preserving.\nρ::QuEST density matrix: The density matrix to apply the operation to.\nq::Tuple{Int64, Int64}: The qubits to apply the operation to.\ncomplex_mat::Array{ComplexF64, 4}: The array of Kraus operators.\nnum_ops::Int64: The number of Kraus operators.\n\nExamples\n\nnum_qubits = 2\nq = (1, 2)\nnum_ops = 4\ncomplex_mat = Array{ComplexF64, 4}(undef, 2, 2, 2, num_ops)\nquantum_env = createQuESTEnv()\nρ = createDensityQureg(num_qubits, quantum_env)\napply_kraus_map!(Quest(),TwoQubits(),NotTracePreserving(),ρ,q,complex_mat,num_ops)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.apply_kraus_map!-Tuple{Quest, TwoQubits, TracePreserving, Vararg{Any, 4}}","page":"API","title":"VeriQuEST.apply_kraus_map!","text":"apply_kraus_map!(::Quest,::TwoQubits,::TracePreserving,ρ,q,complex_mat,num_ops)\n\nApplies a Kraus map to a density matrix for two qubits.\n\nArguments\n\n::Quest: Indicates that this function is used in the context of a Quest environment.\n::TwoQubits: Indicates that the operation is applied to two qubits.\n::TracePreserving: Indicates that the operation is trace preserving.\nρ::QuEST density matrix: The density matrix to apply the operation to.\nq::Tuple{Int64, Int64}: The qubits to apply the operation to.\ncomplex_mat::Array{ComplexF64, 4}: The array of Kraus operators.\nnum_ops::Int64: The number of Kraus operators.\n\nExamples\n\nnum_qubits = 2\nq = (1, 2)\nnum_ops = 4\ncomplex_mat = Array{ComplexF64, 4}(undef, 2, 2, 2, num_ops)\nquantum_env = createQuESTEnv()\nρ = createDensityQureg(num_qubits, quantum_env)\napply_kraus_map!(Quest(),TwoQubits(),TracePreserving(),ρ,q,complex_mat,num_ops)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.assert_comment-Tuple{Any, Any}","page":"API","title":"VeriQuEST.assert_comment","text":"assert_comment(condition, message)\n\nAsserts that a given condition is true. If the condition is false, the function throws an AssertionError with the provided message.\n\nArguments\n\ncondition: The condition to be checked.\nmessage: The message to be displayed if the assertion fails.\n\nExamples\n\nassert_comment(1 == 1, \"Numbers are not equal\") # Does not throw an error\nassert_comment(1 == 2, \"Numbers are not equal\") # Throws an AssertionError\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.assert_flow-Tuple{BackwardFlow, MBQCResourceState, Int64}","page":"API","title":"VeriQuEST.assert_flow","text":"assert_flow(::BackwardFlow, resource::MBQCResourceState, vertex::Int64)\n\nAsserts the properties of a backward flow in a MBQC resource state.\n\nArguments:\n\n::BackwardFlow: The backward flow type.\nresource::MBQCResourceState: The MBQC resource state.\nvertex::Int64: The vertex to be checked.\n\nThe function checks the following properties of the backward flow:\n\nThe flow of the given vertex is in the vertex set of the resource state.\nThe given vertex is in the neighborhood of the flow of the given vertex.\nThe given vertex is less than or equal to all vertices in the neighborhood of the flow of the given vertex.\n\nThrows an error with an appropriate message if any of the properties are violated.\n\nExamples\n\nassert_flow(BackwardFlow(), resource, vertex) # Asserts the properties of the backward flow\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.assert_flow-Tuple{ForwardFlow, MBQCResourceState, Int64}","page":"API","title":"VeriQuEST.assert_flow","text":"assert_flow(flow_type, resource, vertex)\n\nCheck the validity of a flow in a resource graph.\n\nArguments:\n\nflow_type: The type of flow to be checked.\nresource: The resource state representing the graph.\nvertex: The vertex to be checked.\n\nThis function performs several assertions to verify the flow:\n\nChecks if the flow of the given vertex is in the vertex set of the graph.\nChecks if the given vertex is in the neighborhood of the flow of the vertex.\nChecks if the given vertex is less than or equal to the flow of the vertex.\nChecks if all vertices in the neighborhood of the flow of the vertex are greater than or equal to the vertex.\n\nExamples\n\nassert_flow(ForwardFlow(), resource, vertex) # Checks the validity of the forward flow\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.c_iterator-Tuple{Any}","page":"API","title":"VeriQuEST.c_iterator","text":"c_iterator(N)\n\nCreate a C based index iterator that generates numbers from 0 to N-1.\n\nArguments\n\nN: The upper limit for the circular iterator.\n\nReturns\n\nA circular iterator that generates numbers from 0 to N-1.\n\nExamples\n\n# Create a circular iterator\nN = 5\niterator = c_iterator(N)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.c_shift_index-Tuple{Any}","page":"API","title":"VeriQuEST.c_shift_index","text":"c_shift_index(n::Int)\n\nCompute the shifted index n-1 for circular indexing.\n\nArguments\n\nn::Int: The input index.\n\nReturns\n\nThe shifted index n-1 for circular indexing.\n\nExamples\n\n# Compute the shifted index\nn = 3\nshifted_index = c_shift_index(n)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.clone_graph-Tuple{Server, Any}","page":"API","title":"VeriQuEST.clone_graph","text":"clone_graph(::Server,client_graph)\n\nCreates a clone of a graph in the context of a server.\n\nArguments\n\n::Server: Indicates that this function is used in the context of a server.\nclient_graph: The graph to be cloned.\n\nExamples\n\nclone_graph(Server(),client_graph)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.clone_qureq-Tuple{Server, Any, Any}","page":"API","title":"VeriQuEST.clone_qureq","text":"clone_qureq(::Server,client_qureg,env)\n\nCreates a clone of a quantum register in the context of a server.\n\nArguments\n\n::Server: Indicates that this function is used in the context of a server.\nclient_qureg: The quantum register to be cloned.\nenv: The QuEST environment in which the quantum register is cloned.\n\nExamples\n\nclone_qureq(Server(),client_qureg,env)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.compute_angle_δᵥ-Tuple{ComputationRound, InputQubits, Vararg{Any, 6}}","page":"API","title":"VeriQuEST.compute_angle_δᵥ","text":"Computation of δᵥ\n\nThis function computes the value of δᵥ based on the given parameters.\n\nCase\n\nRound ≡ Computation ∩ Qubit ∈ Input set  → δᵥ = ϕᵥ + (θᵥ + xᵥπ) + rᵥπ\n\nArguments:\n\n::ComputationRound: The computation round.\n::InputQubits: The input qubits.\nϕ: The value of ϕ.\nSx: The value of Sx.\nSz: The value of Sz.\nθᵥ: The value of θᵥ.\nrᵥ: The value of rᵥ.\nxᵥ: The value of xᵥ.\n\nReturns:\n\nδᵥ: The computed value of δᵥ.\n\nExamples\n\njulia> compute_angle_δᵥ(ComputationRound(),InputQubits(),0,0,[0,0,0],0,0,0)\n0\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.compute_angle_δᵥ-Tuple{ComputationRound, NoInputQubits, Vararg{Any, 5}}","page":"API","title":"VeriQuEST.compute_angle_δᵥ","text":"compute_angle_δᵥ(::ComputationRound,::NoInputQubits,ϕ,Sx,Sz,θᵥ,rᵥ)\n\nCompute the angle δᵥ based on the given parameters.\n\nComputation of δᵥ Case\n\nRound ≡ Computation ∩ Qubit ∉ Input set  → δᵥ = ϕᵥ′ + θᵥ + rᵥπ\n\nArguments\n\n::ComputationRound: The computation round.\n::NoInputQubits: The number of input qubits.\nϕ: The value of ϕ.\nSx: The value of Sx.\nSz: The value of Sz.\nθᵥ: The value of θᵥ.\nrᵥ: The value of rᵥ.\n\nReturns\n\nδᵥ: The computed angle δᵥ.\n\nExample\n\njulia> compute_angle_δᵥ(ComputationRound(),NoInputQubits(),0,0,[0,0,0],0,0)\n0\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.compute_angle_δᵥ-Tuple{MBQC, Union{InputQubits, NoInputQubits}, Any, Any, Any}","page":"API","title":"VeriQuEST.compute_angle_δᵥ","text":"compute_angle_δᵥ(mbqc, qubits, ϕ, Sx, Sz)\n\nCompute the angle δᵥ for the given MBQC, qubits, ϕ, Sx, and Sz.\n\nArguments\n\nmbqc: The MBQC object.\nqubits: The qubits object, either NoInputQubits or InputQubits.\nϕ: The angle ϕ.\nSx: The Sx value.\nSz: The Sz value.\n\nReturns\n\nThe updated angle δᵥ.\n\nExample\n\njulia> compute_angle_δᵥ(MBQC(), NoInputQubits(), 0, 0, [0, 0, 0])\n0\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.compute_angle_δᵥ-Tuple{TestRound, DummyQubit, Any}","page":"API","title":"VeriQuEST.compute_angle_δᵥ","text":"Computation of δᵥ\n\nThis function computes the angle δᵥ based on the given parameters.\n\nArguments:\n\n::TestRound: The test round object.\n::DummyQubit: The dummy qubit object.\nθᵥ: The input angle.\n\nReturns:\n\nδᵥ: The computed angle δᵥ.\n\nCase:\n\nRound ≡ Test ∩ Qubit ≡ Dummy  → δᵥ = {kπ/r | k ∼ U(0..7)}\n\nExamples\n\njulia> compute_angle_δᵥ(TestRound(),DummyQubit(),0)\n0\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.compute_angle_δᵥ-Tuple{TestRound, TrapQubit, Any, Any}","page":"API","title":"VeriQuEST.compute_angle_δᵥ","text":"compute_angle_δᵥ(::TestRound, ::TrapQubit, θᵥ, rᵥ)\n\nCompute the angle δᵥ for the case where the round is a test round and the qubit is a trap qubit.\n\nComputation of δᵥ Case\n\nRound ≡ Test ∩ Qubit ≡ Trap  → δᵥ = θᵥ + rᵥπ\n\nArguments\n\n::TestRound: The type representing a test round.\n::TrapQubit: The type representing a trap qubit.\nθᵥ: The angle θᵥ.\nrᵥ: The coefficient rᵥ.\n\nReturns\n\nThe computed angle δᵥ.\n\nExample\n\njulia> compute_angle_δᵥ(TestRound(), TrapQubit(), 0, 0)\n0\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.compute_backward_flow-Tuple{Any, Any, Any}","page":"API","title":"VeriQuEST.compute_backward_flow","text":"compute_backward_flow(graph, forward_flow, vertex)\n\nThis function computes the backward flow of a given vertex in a graph.  It first finds the neighbors of the vertex and checks if the vertex is in the forward flow of any of its neighbors.  If it is not, the function returns 0.  If it is, the function finds the index of the vertex in the forward flow of its neighbors.  If the vertex is not in the flow of the neighbors, an error is thrown.  If there is more than one past vertex found, an error is thrown.  Otherwise, the function returns the first past vertex.\n\nArguments\n\ngraph: The graph.\nforward_flow: The forward flow function.\nvertex: The vertex for which to compute the backward flow.\n\nReturns\n\nThe first past vertex if it exists, 0 otherwise.\n\nExamples\n\ngraph = Graph(5)\nforward_flow = (n -> n + 1)\nvertex = 3\nbackward_flow_vertex = compute_backward_flow(graph, forward_flow, vertex)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.compute_trap_round_fail_threshold-Tuple{Any, Any, Any, InherentBoundedError}","page":"API","title":"VeriQuEST.compute_trap_round_fail_threshold","text":"compute_trap_round_fail_threshold(total_rounds, computational_rounds, number_different_test_rounds, inherent_bounded_error::InherentBoundedError)\n\nComputes the threshold for trap round failures. The function first calculates the number of test rounds by subtracting the number of computational rounds from the total rounds. It then uses this number, the number of different test rounds, and the inherent bounded error to calculate the threshold, which is then floored to the nearest integer.\n\nArguments\n\ntotal_rounds: The total number of rounds.\ncomputational_rounds: The number of computational rounds.\nnumber_different_test_rounds: The number of different test rounds.\ninherent_bounded_error::InherentBoundedError: An instance of InherentBoundedError representing the inherent bounded error.\n\nReturns\n\nInt: The floored threshold for trap round failures.\n\nExamples\n\ntotal_rounds = 10\ncomputational_rounds = 5\nnumber_different_test_rounds = 3\ninherent_bounded_error = InherentBoundedError(0.33)\nthreshold = compute_trap_round_fail_threshold(total_rounds, computational_rounds, number_different_test_rounds, inherent_bounded_error)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.convert_flow_type_symbol-Tuple{Client, Union{BackwardFlow, ForwardFlow}}","page":"API","title":"VeriQuEST.convert_flow_type_symbol","text":"convert_flow_type_symbol(::Client, flow_type::Union{ForwardFlow,BackwardFlow})\n\nThis function converts a flow type (either ForwardFlow or BackwardFlow) into a symbol.  The conversion process involves converting the flow type to a string, removing parentheses,  adding an underscore before \"Flow\", converting to lowercase, and finally converting to a symbol.\n\nArguments\n\n::Client: The Client object.\nflow_type::Union{ForwardFlow,BackwardFlow}: The flow type to be converted.\n\nReturns\n\nA Symbol representing the flow type.\n\nExamples\n\nclient = Client()\nflow_type = ForwardFlow()\nflow_sym = convert_flow_type_symbol(client, flow_type)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.create_graph_resource-Tuple{NamedTuple}","page":"API","title":"VeriQuEST.create_graph_resource","text":"create_graph_resource(p::NamedTuple)::MBQCResourceState\n\nCreates an MBQCResourceState from a NamedTuple p. The NamedTuple should contain the following keys: input_indices, input_values, output_indices, computation_colours, test_colours, graph, forward_flow, backward_flow, and secret_angles.\n\nArguments\n\np: A NamedTuple containing the necessary parameters to create an MBQCResourceState.\n\nExamples\n\nparams = (input_indices = ..., input_values = ..., output_indices = ..., computation_colours = ..., test_colours = ..., graph = ..., forward_flow = ..., backward_flow = ..., secret_angles = ...)\nresource = create_graph_resource(params)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.create_plus_phase_density_mat-Tuple{Any}","page":"API","title":"VeriQuEST.create_plus_phase_density_mat","text":"create_plus_phase_density_mat(θ)\n\nCreate a density matrix for the plus phase state with a given phase angle θ.\n\nArguments\n\nθ: Phase angle in radians.\n\nReturns\n\nDensity matrix representing the plus phase state with the given phase angle.\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.create_quantum_env-Tuple{Client}","page":"API","title":"VeriQuEST.create_quantum_env","text":"create_quantum_env(client::Client)\n\nCreate a new quantum environment using the QuEST environment creation function.\n\nArguments\n\nclient::Client: The client for which the quantum environment is being created.\n\nReturns\n\nA new quantum environment.\n\nExamples\n\nclient = Client()\nenv = create_quantum_env(client)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.create_quantum_env-Tuple{Server}","page":"API","title":"VeriQuEST.create_quantum_env","text":"create_quantum_env(::Server)\n\nCreates a new QuEST environment in the context of a server.\n\nArguments\n\n::Server: Indicates that this function is used in the context of a server.\n\nExamples\n\ncreate_quantum_env(Server())\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.create_quantum_state-Tuple{Client, DensityMatrix, Any, Any}","page":"API","title":"VeriQuEST.create_quantum_state","text":"create_quantum_state(client::Client, density_matrix::DensityMatrix, quantum_env, num_qubits)\n\nCreate a quantum state using a density matrix representation.\n\nArguments\n\nclient::Client: The client object representing the quantum computing service.\ndensity_matrix::DensityMatrix: The density matrix object representing the quantum state.\nquantum_env: The quantum environment object.\nnum_qubits: The number of qubits to be used in the quantum state.\n\nReturns\n\nThe quantum state represented as a density matrix.\n\nExamples\n\nclient = Client()\nenv = create_quantum_env(client)\nstate = create_quantum_state(client, DensityMatrix(), env, 2)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.create_quantum_state-Tuple{Client, StateVector, Any, Any}","page":"API","title":"VeriQuEST.create_quantum_state","text":"create_quantum_state(client::Client, state::StateVector, quantum_env, num_qubits)\n\nCreate a new quantum state as a state vector using the QuEST function createQureg.\n\nArguments\n\nclient::Client: The client for which the quantum state is being created.\nstate::StateVector: Indicates that the quantum state should be created as a state vector.\nquantum_env: The quantum environment in which the quantum state is being created.\nnum_qubits: The number of qubits in the quantum state.\n\nReturns\n\nA new quantum state as a state vector.\n\nExamples\n\nclient = Client()\nenv = create_quantum_env(client)\nstate = create_quantum_state(client, StateVector(), env, 2)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.create_quantum_state-Tuple{Server, DensityMatrix, Any, Any}","page":"API","title":"VeriQuEST.create_quantum_state","text":"create_quantum_state(::Server,::DensityMatrix,quantum_env,num_qubits)\n\nCreates a new quantum state in the context of a server.\n\nArguments\n\n::Server: Indicates that this function is used in the context of a server.\n::DensityMatrix: Indicates that the quantum state is a density matrix.\nquantum_env: The QuEST environment in which the quantum state is created.\nnum_qubits: The number of qubits in the quantum state.\n\nExamples\n\ncreate_quantum_state(Server(),DensityMatrix(),quantum_env,num_qubits)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.create_quantum_state-Tuple{Server, StateVector, Any, Any}","page":"API","title":"VeriQuEST.create_quantum_state","text":"create_quantum_state(::Server,::StateVector,quantum_env,num_qubits)\n\nCreates a new quantum state in the context of a server.\n\nArguments\n\n::Server: Indicates that this function is used in the context of a server.\n::StateVector: Indicates that the quantum state is a state vector.\nquantum_env: The QuEST environment in which the quantum state is created.\nnum_qubits: The number of qubits in the quantum state.\n\nExamples\n\ncreate_quantum_state(Server(),StateVector(),quantum_env,num_qubits)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.create_resource-Tuple{MaliciousServer, Any, Any, Union{Float64, Vector{Float64}}}","page":"API","title":"VeriQuEST.create_resource","text":"create_resource(::MaliciousServer, client_graph, client_qureg, malicious_angles::Union{Float64,Vector{Float64}})\n\nCreates a resource dictionary for a malicious server, including a cloned graph, a quantum environment, a quantum register, and a set of malicious angles.\n\nArguments\n\n::MaliciousServer: Indicates that this function is used in the context of a malicious server.\nclient_graph::Graph: The client's graph to be cloned.\nclient_qureg::QuEST object: The client's quantum register to be cloned.\nmalicious_angles::Union{Float64,Vector{Float64}}: The angles to be used for malicious behavior.\n\nExamples\n\nclient_graph = create_graph(Client(), 3)\nclient_qureg = create_qureg(Client(), 3)\nmalicious_angles = [π/4, π/2, 3π/4]\ncreate_resource(MaliciousServer(), client_graph, client_qureg, malicious_angles)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.create_resource-Tuple{NoisyServer, Any, Any}","page":"API","title":"VeriQuEST.create_resource","text":"create_resource(server::NoisyServer, client_graph, client_qureg)\n\nCreates a resource for a NoisyServer by cloning the client's graph and quantum register, adding noise to the server's quantum register, and entangling the server's graph. Returns a dictionary containing the server's quantum environment, quantum state, and graph.\n\nArguments\n\nserver::NoisyServer: A NoisyServer instance to which the resource will be created.\nclient_graph: The client's graph to be cloned.\nclient_qureg: The client's quantum register to be cloned.\n\nReturns\n\nDict: A dictionary containing the server's quantum environment (\"env\"), quantum state (\"quantum_state\"), and graph (\"graph\").\n\nExamples\n\nserver = NoisyServer(noise_model)\nclient_graph = create_graph(Client(), 3)\nclient_qureg = QuantumRegister(3)\nresource = create_resource(server, client_graph, client_qureg)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.create_resource-Tuple{Server, Any, Any}","page":"API","title":"VeriQuEST.create_resource","text":"create_resource(::Server,client_graph,client_qureg)\n\nCreates a resource in the context of a server.\n\nArguments\n\n::Server: Indicates that this function is used in the context of a server.\nclient_graph: The graph to be copied/cloned.\nclient_qureg: The quantum register to be copied/cloned.\n\nExamples\n\ncreate_resource(Server(),client_graph,client_qureg)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.create_ubqc_resource-Tuple{Any}","page":"API","title":"VeriQuEST.create_ubqc_resource","text":"create_ubqc_resource(para)\n\nCreates a UBQC (Universal Blind Quantum Computation) resource using the provided parameters. The function initializes the test and computation colours, computes the backward flow, and creates a dictionary with the parameters. It then calls the create_graph_resource function with the created dictionary as an argument.\n\nArguments\n\npara: A dictionary containing the parameters for the UBQC resource. It should include the following keys: :input, :output, :graph, :secret_angles, and :forward_flow.\n\nReturns\n\nThe result of the create_graph_resource function.\n\nExamples\n\npara = (args)::NamedTuple # function specific args\nubqc_resource = create_ubqc_resource(para)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.draw_bit-Tuple{}","page":"API","title":"VeriQuEST.draw_bit","text":"draw_bit()\n\nDraw a random bit, either 0 or 1. This function uses the rand function to randomly select from the array [0,1].\n\nReturns\n\nA random bit, either 0 or 1.\n\nExamples\n\ndraw_bit() # Outputs: 0 or 1\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.draw_dᵥ-Tuple{}","page":"API","title":"VeriQuEST.draw_dᵥ","text":"draw_dᵥ()\n\nDraw a random bit, either 0 or 1, for a dummy. This function uses the draw_bit function to select the bit.\n\nReturns\n\nA random bit, either 0 or 1, for a dummy.\n\nExamples\n\njulia draw_dᵥ() # Outputs: 0 or 1`\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.draw_random_rounds-Tuple{Any, Any}","page":"API","title":"VeriQuEST.draw_random_rounds","text":"draw_random_rounds(total_rounds, computation_rounds)\n\nGenerates a random sequence of computation and test rounds. The function first calculates the number of test rounds by subtracting the number of computation rounds from the total rounds. It then creates arrays of ComputationRound and TestRound instances, and returns a shuffled concatenation of these arrays.\n\nArguments\n\ntotal_rounds: The total number of rounds.\ncomputation_rounds: The number of computation rounds.\n\nReturns\n\nArray: A shuffled array of ComputationRound and TestRound instances.\n\nExamples\n\ntotal_rounds = 10\ncomputation_rounds = 5\nrounds = draw_random_rounds(total_rounds, computation_rounds)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.draw_rᵥ-Tuple{}","page":"API","title":"VeriQuEST.draw_rᵥ","text":"draw_rᵥ()\n\nDraw a random bit, either 0 or 1, for a trap. This function uses the draw_bit function to select the bit.\n\nReturns\n\nA random bit, either 0 or 1, for a trap.\n\nExamples\n\ndraw_rᵥ() # Outputs: 0 or 1\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.draw_θᵥ-Tuple{}","page":"API","title":"VeriQuEST.draw_θᵥ","text":"draw_θᵥ()\n\nDraw a random angle θ that is a multiple of kπ/4, where k is an integer between 0 and 7, inclusive. This function uses the rand_k_0_7 function to select k, and then calculates θ.\n\nReturns\n\nA random angle θ that is a multiple of kπ/4.\n\nExamples\n\ndraw_θᵥ() # Outputs: A multiple of π/4 between 0 and 7π/4\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.entangle_graph!-Tuple{Client, Any}","page":"API","title":"VeriQuEST.entangle_graph!","text":"entangle_graph!(::Client, mg)\n\nThis function entangles the quantum state of a meta graph for a client in the MBQC model.  It first retrieves the quantum state from the meta graph and creates a graph from the meta graph.  Then, for each edge in the graph, it applies a controlled phase flip operation on the source and destination vertices.\n\nArguments\n\n::Client: The Client object.\nmg: The MetaGraph to which the properties will be added.\n\nExamples\n\nclient = Client()\nmg = MetaGraphs.MetaGraph(graph)\nentangle_graph!(client, mg)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.entangle_graph!-Tuple{Server, Any, Any}","page":"API","title":"VeriQuEST.entangle_graph!","text":"entangle_graph!(::Server,qureg,graph)\n\nEntangles a quantum register with a graph in the context of a server.\n\nArguments\n\n::Server: Indicates that this function is used in the context of a server.\nqureg: The quantum register to be entangled.\ngraph: The graph with which the quantum register is entangled.\n\nExamples\n\nentangle_graph!(Server(),qureg,graph)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.generate_property_graph!-Tuple{Client, Any, MBQCResourceState, Union{DensityMatrix, StateVector}}","page":"API","title":"VeriQuEST.generate_property_graph!","text":"generate_property_graph!(::Client, round_type, resource::MBQCResourceState, state_type::Union{StateVector,DensityMatrix})\n\nThis function generates a property graph for a client in the MBQC model based on the round type.  It first creates a meta graph from the resource and adds the round type to it.  Then, it adds output qubits, sets the vertex type and IO qubits type, initializes the qubits,  adds flow vertices and correction vertices, initializes measurement outcomes,  and initializes the quantum state of the meta graph.  This function is run at the beginning of every round.\n\nArguments\n\n::Client: The Client object.\nround_type: The round type.\nresource::MBQCResourceState: The resource containing the graph and its coloring.\nstate_type::Union{StateVector,DensityMatrix}: The type of quantum state to create.\n\nReturns\n\nThe updated MetaGraph.\n\nExamples\n\nclient = Client()\nresource = MBQCResourceState(graph)\nround_type = \"round1\"\nstate_type = StateVector()\ngenerate_property_graph!(client, round_type, resource, state_type)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.generate_property_graph!-Tuple{Client, MBQC, MBQCResourceState, Union{DensityMatrix, StateVector}}","page":"API","title":"VeriQuEST.generate_property_graph!","text":"generate_property_graph!(::Client, round_type::MBQC, resource::MBQCResourceState, state_type::Union{StateVector,DensityMatrix})\n\nThis function generates a property graph for a client in the MBQC model based on the round type.  It first creates a meta graph from the resource and adds the round type to it.  Then, it adds output qubits, sets the vertex type and IO qubits type, initializes the qubits,  adds flow vertices and correction vertices, initializes measurement outcomes,  initializes the quantum state of the meta graph, and entangles the graph.  This function is run at the beginning of every round.\n\nArguments\n\n::Client: The Client object.\nround_type::MBQC: The round type.\nresource::MBQCResourceState: The resource containing the graph and its coloring.\nstate_type::Union{StateVector,DensityMatrix}: The type of quantum state to create.\n\nReturns\n\nThe updated MetaGraph.\n\nExamples\n\nclient = Client()\nresource = MBQCResourceState(graph)\nround_type = MBQC()\nstate_type = StateVector()\ngenerate_property_graph!(client, round_type, resource, state_type)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.generate_random_greedy_color-Tuple{Any, Any}","page":"API","title":"VeriQuEST.generate_random_greedy_color","text":"generate_random_greedy_color(g, reps)\n\nThis function generates a random greedy coloring of a graph. It uses the random_greedy_color function from the Graphs package.\n\nArguments\n\ng: The graph to be colored.\nreps: The number of repetitions for the random greedy coloring algorithm.\n\nExamples\n\ng = Graphs.grid_graph((5,5))\nreps = 10\ngenerate_random_greedy_color(g, reps)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_angle-Tuple{MBQCResourceState, Any, Any}","page":"API","title":"VeriQuEST.get_angle","text":"get_angle(resource::MBQCResourceState, AngleType, vertex)\n\nReturns the angle of a specific vertex from a given MBQCResourceState and AngleType.\n\nArguments\n\nresource: An MBQCResourceState from which to extract the angle.\nAngleType: The type of angle to be extracted.\nvertex: The vertex for which to extract the angle.\n\nExamples\n\nangle = get_angle(resource, SecretAngles(), vertex) # Returns the angle of the specified vertex\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_angles-Tuple{MBQCResourceState, SecretAngles}","page":"API","title":"VeriQuEST.get_angles","text":"get_angles(resource::MBQCResourceState, ::SecretAngles)\n\nReturns the secret angles from a given MBQCResourceState.\n\nArguments\n\nresource: An MBQCResourceState from which to extract the secret angles.\n\nExamples\n\nangles = get_angles(resource, SecretAngles()) # Returns the secret angles of the resource\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_correction_vertices-Tuple{MBQCResourceState, Int64}","page":"API","title":"VeriQuEST.get_correction_vertices","text":"get_correction_vertices(resource::MBQCResourceState, vertex::Int64)\n\nReturns the corrections for a given vertex in the MBQC resource state.\n\nArguments\n\nresource::MBQCResourceState: The MBQC resource state.\nvertex::Int64: The vertex for which to get the corrections.\n\nReturns\n\ncorrections: A tuple containing the X and Z corrections.\n\nExample\n\ncorrections = get_correction_vertices(resource, vertex) # Returns the corrections needed for the given vertex\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_corrections_multi_neighbourhood_mulit_vertex_graph-Tuple{MBQCResourceState, Int64}","page":"API","title":"VeriQuEST.get_corrections_multi_neighbourhood_mulit_vertex_graph","text":"get_corrections_multi_neighbourhood_mulit_vertex_graph(resource::MBQCResourceState, vertex::Int64)\n\nThis function calculates the corrections needed for a multi-neighbourhood multi-vertex graph in the context of MBQC (Measurement-Based Quantum Computation).\n\nArguments\n\nresource::MBQCResourceState: The MBQC resource state.\nvertex::Int64: The vertex for which the corrections are calculated.\n\nReturns\n\ncorrections: A tuple containing the X and Z corrections.\n\nExample\n\ncorrections = get_corrections_multi_neighbourhood_mulit_vertex_graph(resource, vertex) # Returns the corrections needed for the given vertex\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_corrections_one_neighbourhood_mulit_vertex_graph-Tuple{MBQCResourceState, Int64}","page":"API","title":"VeriQuEST.get_corrections_one_neighbourhood_mulit_vertex_graph","text":"get_corrections_one_neighbourhood_mulit_vertex_graph(resource::MBQCResourceState, vertex::Int64)\n\nThis function calculates the corrections needed for a vertex in a multi-vertex graph with one neighbourhood. It takes the resource state resource and the vertex vertex as input.\n\nArguments\n\nresource::MBQCResourceState: The resource state of the graph.\nvertex::Int64: The vertex for which corrections are calculated.\n\nReturns\n\ncorrections::NamedTuple: A named tuple containing the X and Z corrections for the vertex.\n\nExample\n\ncorrections = get_corrections_one_neighbourhood_mulit_vertex_graph(resource, vertex) # Returns the corrections needed for the given vertex\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_corrections_one_neighbourhood_two_vertex_graph-Tuple{MBQCResourceState, Int64}","page":"API","title":"VeriQuEST.get_corrections_one_neighbourhood_two_vertex_graph","text":"get_corrections_one_neighbourhood_two_vertex_graph(resource::MBQCResourceState, vertex::Int64)\n\nThis function calculates the corrections needed for a two-vertex graph in a one-neighbourhood MBQC resource state.\n\nArguments\n\nresource::MBQCResourceState: The MBQC resource state.\nvertex::Int64: The vertex in the graph.\n\nReturns\n\ncorrections: A tuple (X=x_correction_vertex, Z=z_correction_vertices) representing the corrections needed.\n\nErrors\n\nThrows an error if the vertex is not in the graph.\nThrows an error if the size of the graph is not 2.\nThrows an error if the size of the vertex neighbour set is not 1.\nThrows an error if neither the forward flow nor the backward flow of the vertex is in the graph.\n\nExamples\n\ncorrections = get_corrections_one_neighbourhood_two_vertex_graph(resource, vertex) # Returns the corrections needed for the given vertex\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_edge_iterator-Tuple{MBQCResourceState}","page":"API","title":"VeriQuEST.get_edge_iterator","text":"get_edge_iterator(resource::MBQCResourceState)\n\nRetrieve an iterator over the edges in an MBQC resource state.\n\nArguments\n\nresource::MBQCResourceState: An MBQC resource state containing the graph representation of the resource.\n\nReturns\n\nAn iterator over the edges of the resource state's graph.\n\nExamples\n\n# Create an MBQC resource state\ngraph = MBQCGraph(...)\nflow = MBQCFlow(...)\nangles = MBQCAngles(...)\nresource = MBQCResourceState(graph, flow, angles)\n\n# Get the edge iterator\nedge_iterator = get_edge_iterator(resource)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_flow-Tuple{BackwardFlow, MBQCResourceState}","page":"API","title":"VeriQuEST.get_flow","text":"get_flow(flow_type::BackwardFlow, resource::MBQCResourceState)\n\nGet the backward flow of a given resource.\n\nArguments\n\nflow_type::BackwardFlow: The type of flow to retrieve.\nresource::MBQCResourceState: The resource state to retrieve the flow from.\n\nReturns\n\nThe backward flow of the resource.\n\nExamples\n\n```julia\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_flow-Tuple{ForwardFlow, MBQCResourceState}","page":"API","title":"VeriQuEST.get_flow","text":"get_flow(flow_type, resource)\n\nGet the flow of a given resource.\n\nArguments\n\nflow_type: The type of flow (e.g., ForwardFlow, BackwardFlow).\nresource: The resource state.\n\nReturns\n\nThe flow of the resource.\n\nExamples\n\n```julia\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_graph-Tuple{MBQCResourceState}","page":"API","title":"VeriQuEST.get_graph","text":"get_graph(resource::MBQCResourceState)\n\nGet the graph associated with the given MBQCResourceState.\n\nArguments\n\nresource::MBQCResourceState: The resource state object.\n\nReturns\n\nThe graph associated with the resource state.\n\nExamples\n\ngraph = get_graph(resource) # Returns the graph associated with the resource\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_input_indices-Tuple{MBQCResourceState}","page":"API","title":"VeriQuEST.get_input_indices","text":"get_input_indices(resource::MBQCResourceState)\n\nReturns the input indices from a given MBQCResourceState.\n\nArguments\n\nresource: An MBQCResourceState from which to extract the input indices.\n\nExamples\n\nindices = get_input_indices(resource) # Returns the input indices of the resource\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_input_size-Tuple{MBQCResourceState}","page":"API","title":"VeriQuEST.get_input_size","text":"get_input_size(resource::MBQCResourceState)::Int64\n\nGet the size of the input for the given MBQCResourceState.\n\nArguments\n\nresource::MBQCResourceState: The MBQC resource state.\n\nReturns\n\nInt64: The size of the input.\n\nExamples\n\nsize = get_input_size(resource) # Returns the size of the input\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_input_value-Tuple{MBQCResourceState, Any}","page":"API","title":"VeriQuEST.get_input_value","text":"get_input_value(resource::MBQCResourceState, iter)\n\nReturns the input value at the iter-th index from a given MBQCResourceState. If iter is greater than the length of the input indices, the function returns nothing.\n\nArguments\n\nresource: An MBQCResourceState from which to extract the input value.\niter: The index at which to extract the input value.\n\nExamples\n\nvalue = get_input_value(resource, 1) # Returns the input value at the first index of the resource\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_input_values-Tuple{MBQCResourceState}","page":"API","title":"VeriQuEST.get_input_values","text":"get_input_values(resource::MBQCResourceState)\n\nReturns the input values from a given MBQCResourceState.\n\nArguments\n\nresource: An MBQCResourceState from which to extract the input values.\n\nExamples\n\nvalues = get_input_values(resource) # Returns the input values of the resource\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_measurement_outcome_iterator-Tuple{MBQCResourceState}","page":"API","title":"VeriQuEST.get_measurement_outcome_iterator","text":"get_measurement_outcome_iterator(resource::MBQCResourceState)\n\nReturns an iterator that generates indices for measuring the vertices of a MBQC resource state.\n\nArguments\n\nresource::MBQCResourceState: The MBQC resource state.\n\nReturns\n\nAn iterator that generates indices for measuring the vertices of the resource state.\n\nExample\n\niterator = get_measurement_outcome_iterator(resource) # Returns an iterator that generates indices for measuring the vertices of the resource\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_minimum_vertex_index_flow-Tuple{MBQCResourceState}","page":"API","title":"VeriQuEST.get_minimum_vertex_index_flow","text":"get_minimum_vertex_index_flow(resource::MBQCResourceState)\n\nGet the minimum vertex index flow for a given MBQCResourceState.\n\nArguments\n\nresource::MBQCResourceState: The MBQC resource state.\n\nReturns\n\nInt64: The minimum vertex index flow.\n\nExample\n\nmin_vertex = get_minimum_vertex_index_flow(resource) # Returns the minimum vertex index flow\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_mode_output-Tuple{Client, ComputationRound, Vector}","page":"API","title":"VeriQuEST.get_mode_output","text":"get_mode_output(::Client, ::ComputationRound, rounds_as_graphs::Vector)\n\nCollects the outputs of computation rounds from a list of client's meta graphs and returns the mode of the outputs. The function iterates over the meta graphs, skips those with a round type of TestRound, gets the output of the computation round, and stores it in a list. The function then calculates and returns the mode of the outputs.\n\nArguments\n\n::Client: A Client instance.\n::ComputationRound: A ComputationRound instance.\nrounds_as_graphs::Vector: A list of client's meta graphs.\n\nReturns\n\nmode(outputs): The mode of the outputs.\n\nExamples\n\nrounds_as_graphs = [create_meta_graph(Client()) for _ in 1:5]\nmode_output = get_mode_output(Client(), ComputationRound(), rounds_as_graphs)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_noise_model-Tuple{Damping}","page":"API","title":"VeriQuEST.get_noise_model","text":"get_noise_model(::Damping)\n\nGet the noise model for a given damping type.\n\nArguments\n\n::Damping: The damping type.\n\nReturns\n\nadd_damping!: The noise model function.\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_noise_model-Tuple{Dephasing}","page":"API","title":"VeriQuEST.get_noise_model","text":"get_noise_model(::Dephasing)\n\nGet the noise model for dephasing errors.\n\nArguments\n\n::Dephasing: A dephasing error model.\n\nReturns\n\nadd_dephasing!: A function that adds dephasing errors to a quantum circuit.\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_noise_model-Tuple{Depolarising}","page":"API","title":"VeriQuEST.get_noise_model","text":"get_noise_model(::Depolarising)\n\nGet the noise model for the Depolarising channel.\n\nArguments\n\n::Depolarising: The Depolarising channel.\n\nReturns\n\nadd_depolarising!: The function to add depolarising noise to a quantum circuit.\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_noise_model-Tuple{Kraus}","page":"API","title":"VeriQuEST.get_noise_model","text":"get_noise_model(::Kraus)\n\nGet the noise model for a given Kraus operator.\n\nArguments\n\n::Kraus: The Kraus operator.\n\nReturns\n\nThe noise model.\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_noise_model-Tuple{MixtureDensityMatrices}","page":"API","title":"VeriQuEST.get_noise_model","text":"get_noise_model(::MixtureDensityMatrices)\n\nGet the noise model for a mixture of density matrices.\n\nArguments\n\n::MixtureDensityMatrices: The mixture of density matrices.\n\nReturns\n\nThe noise model.\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_noise_model-Tuple{Pauli}","page":"API","title":"VeriQuEST.get_noise_model","text":"get_noise_model(p::Pauli)\n\nGet the noise model for a given Pauli operator.\n\nArguments\n\np::Pauli: The Pauli operator.\n\nReturns\n\nadd_pauli_noise!: The function to add Pauli noise to a quantum circuit.\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_noise_model_params-Tuple{Union{Damping, Dephasing, Depolarising, Pauli}, Union{DensityMatrix, Qureg}}","page":"API","title":"VeriQuEST.get_noise_model_params","text":"get_noise_model_params(model::Union{Damping,Dephasing,Depolarising,Pauli}, server_qureg::Union{DensityMatrix,Qureg})\n\nGet the noise model parameters for a given noise model and server quantum register.\n\nArguments\n\nmodel::Union{Damping,Dephasing,Depolarising,Pauli}: The noise model to retrieve parameters for.\nserver_qureg::Union{DensityMatrix,Qureg}: The server quantum register.\n\nReturns\n\nThe noise parameters for the given noise model and server quantum register.\n\n```\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_noise_param-Tuple{Kraus}","page":"API","title":"VeriQuEST.get_noise_param","text":"get_noise_param(::Kraus)\n\nGet the noise parameters for a given Kraus operator.\n\nArguments\n\n::Kraus: The Kraus operator.\n\nReturns\n\nKrausMapNoiseParameters: The noise parameters for the Kraus operator.\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_noise_param-Tuple{MixtureDensityMatrices}","page":"API","title":"VeriQuEST.get_noise_param","text":"get_noise_param(::MixtureDensityMatrices)\n\nGet the noise parameter for a MixtureDensityMatrices object.\n\nArguments\n\n::MixtureDensityMatrices: The input MixtureDensityMatrices object.\n\nReturns\n\nMixtureDensityMatrices: The noise parameter.\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_noise_param-Tuple{Union{Damping, Dephasing, Depolarising, Pauli}}","page":"API","title":"VeriQuEST.get_noise_param","text":"get_noise_param(noise_type)\n\nGet the noise parameters for the specified noise type.\n\nArguments\n\nnoise_type: The type of noise (Damping, Dephasing, Depolarising, Pauli).\n\nReturns\n\nQubitNoiseParameters: The noise parameters for the specified noise type.\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_number_vertices-Tuple{MBQCResourceState}","page":"API","title":"VeriQuEST.get_number_vertices","text":"get_number_qubits(resource::MBQCResourceState)\n\nRetrieve the number of qubits in an MBQC resource state.\n\nArguments\n\nresource::MBQCResourceState: An MBQC resource state containing the graph representation of the resource.\n\nReturns\n\nThe number of qubits in the resource state.\n\nExamples\n\n# Create an MBQC resource state\ngraph = MBQCGraph(...)\nflow = MBQCFlow(...)\nangles = MBQCAngles(...)\nresource = MBQCResourceState(graph, flow, angles)\n\n# Get the number of qubits\nnum_qubits = get_number_qubits(resource)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_output-Tuple{Client, Union{ComputationRound, MBQC}, Any}","page":"API","title":"VeriQuEST.get_output","text":"get_output(::Client, ::Union{MBQC,ComputationRound}, mg)\n\nRetrieves the output of a computation from a client's meta graph. The function gets the output indices from the meta graph, iterates over them, gets the outcome for each index, and stores the outcomes in a list. The list of outcomes is returned.\n\nArguments\n\n::Client: A Client instance.\n::Union{MBQC,ComputationRound}: An instance of MBQC or ComputationRound.\nmg: The client's meta graph.\n\nReturns\n\nArray: An array of outcomes.\n\nExamples\n\nmg = create_meta_graph(Client())\noutcomes = get_output(Client(), ComputationRound(), mg)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_output_size-Tuple{MBQCResourceState}","page":"API","title":"VeriQuEST.get_output_size","text":"get_output_size(resource::MBQCResourceState)::Int64\n\nGet the size of the output for a given MBQCResourceState.\n\nArguments\n\nresource::MBQCResourceState: The resource state for which to get the output size.\n\nReturns\n\nInt64: The size of the output.\n\nExamples\n\nsize = get_output_size(resource) # Returns the size of the output\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_random_coloring-Tuple{Vector{Vector{Int64}}}","page":"API","title":"VeriQuEST.get_random_coloring","text":"get_random_coloring(c::Vector{Vector{Int64}})\n\nThis function selects a random coloring from a vector of colorings.\n\nArguments\n\nc::Vector{Vector{Int64}}: The vector of colorings.\n\nExamples\n\njulia c = [[1, 2, 1], [2, 1, 2], [1, 2, 2]] get_random_coloring(c)`\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_size_measurement_vector-Tuple{MBQCResourceState}","page":"API","title":"VeriQuEST.get_size_measurement_vector","text":"get_size_measurement_vector(resource::MBQCResourceState)::Int64\n\nGet the size of the measurement vector for a given MBQCResourceState.\n\nArguments\n\nresource::MBQCResourceState: The resource state for which to calculate the measurement vector size.\n\nReturns\n\nInt64: The size of the measurement vector.\n\nExamples\n\nsize = get_size_measurement_vector(resource) # Returns the size of the measurement vector\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_stop_start_vertices-Tuple{MBQCResourceState}","page":"API","title":"VeriQuEST.get_stop_start_vertices","text":"get_stop_start_vertices(resource::MBQCResourceState)\n\nGet the start and stop vertices for a given MBQCResourceState.\n\nArguments\n\nresource::MBQCResourceState: The MBQC resource state.\n\nReturns\n\nTuple{Int64, Int64}: A tuple containing the start and stop vertices.\n\nExample\n\nstart, stop = get_stop_start_vertices(resource) # Returns the start and stop vertices\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_ubqc_output-Tuple{Client, ComputationRound, MetaGraphs.MetaGraph}","page":"API","title":"VeriQuEST.get_ubqc_output","text":"get_ubqc_output(::Client, ::ComputationRound, mg::MetaGraphs.MetaGraph)\n\nGets the output of a computation round from a client's meta graph. The function checks if the round type of the meta graph is TestRound, and if so, it throws an error. Otherwise, it gets and returns the output of the computation round.\n\nArguments\n\n::Client: A Client instance.\n::ComputationRound: A ComputationRound instance.\nmg::MetaGraphs.MetaGraph: A client's meta graph.\n\nReturns\n\nThe output of the computation round.\n\nErrors\n\nThrows an error if the round type of the meta graph is TestRound.\n\nExamples\n\nubqc_output = get_ubqc_output(Client(), ComputationRound(), mg)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_updated_ϕ!-NTuple{5, Any}","page":"API","title":"VeriQuEST.get_updated_ϕ!","text":"get_updated_ϕ!(RountType, QubitType, QubitIOType, client_meta_graph, qubit)\n\nUpdates the ϕ value of a given qubit in the client_meta_graph using the update_ϕ! function and then retrieves the updated ϕ value.\n\nArguments\n\nRountType: The type of the computation round.\nQubitType: The type of the computation qubit.\nQubitIOType: The type of the input qubits.\nclient_meta_graph: The graph to be updated.\nqubit: The qubit in the graph for which the ϕ value is to be updated and retrieved.\n\nReturns\n\nThe updated ϕ value of the specified qubit.\n\nExamples\n\nupdated_ϕ = get_updated_ϕ!(ComputationRound, ComputationQubit, NoInputQubits, client_meta_graph, qubit) # Updates the ϕ value of the specified qubit in the graph and retrieves it\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_updated_ϕ!-Tuple{Client, Any, Any}","page":"API","title":"VeriQuEST.get_updated_ϕ!","text":"get_updated_ϕ!(::Client, mg, qubit)\n\nIn the context of a client, updates the ϕ value of a given qubit in the mg graph using the get_updated_ϕ! function and then retrieves the updated ϕ value. The round type, vertex type, and vertex IO type are determined from the properties of the graph and the qubit.\n\nArguments\n\n::Client: Indicates that this function is used in the context of a client.\nmg: The graph to be updated.\nqubit: The qubit in the graph for which the ϕ value is to be updated and retrieved.\n\nReturns\n\nThe updated ϕ value of the specified qubit.\n\nExamples\n\nupdated_ϕ = get_updated_ϕ!(Client(), mg, qubit) # Updates the ϕ value of the specified qubit in the graph and retrieves it\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_updated_ϕ!-Tuple{MaliciousServer, Any, Any, Float64}","page":"API","title":"VeriQuEST.get_updated_ϕ!","text":"get_updated_ϕ!(::MaliciousServer, server_resource, qubit, ϕ::Float64)\n\nUpdates the phase angle for a given qubit in a malicious server context.\n\nArguments\n\n::MaliciousServer: Indicates that this function is used in the context of a malicious server.\nserver_resource::Dict: A dictionary containing server resources.\nqubit::Int64: The qubit for which the phase angle is to be updated.\nϕ::Float64: The current phase angle.\n\nReturns\n\nFloat64: The updated phase angle.\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_vector_graph_colors-Tuple{Any}","page":"API","title":"VeriQuEST.get_vector_graph_colors","text":"get_vector_graph_colors(graph; reps=100)\n\nGenerates a vector of graph colors. It first generates a random greedy color for the graph (repeated reps times), then separates each color.\n\nArguments\n\ngraph: The graph to be colored.\nreps: The number of repetitions for generating the random greedy color (default is 100).\n\nExamples\n\nget_vector_graph_colors(graph) # Returns a vector of graph colors\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_verified_flow-Tuple{Any, MBQCResourceState}","page":"API","title":"VeriQuEST.get_verified_flow","text":"get_verified_flow(T, resource::MBQCResourceState)\n\nCreate a function that returns the verified flow output for a given vertex.\n\nArguments\n\nT: The flow graph.\nresource: The MBQC resource state.\n\nReturns\n\nA function f that takes a vertex as input and returns the verified flow output.\n\nExample\n\nT = ForwardFlow()\nresource = MBQCResourceState(...)\nf = get_verified_flow(T, resource) # Returns a function that takes a vertex as input and returns the verified flow output\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_verified_flow_output-Tuple{Any, MBQCResourceState, Int64}","page":"API","title":"VeriQuEST.get_verified_flow_output","text":"get_verified_flow_output(T, resource, vertex)\n\nGet the verified flow output for a given vertex in a MBQC resource state.\n\nArguments\n\nT: The type of flow, which must be either ForwardFlow or BackwardFlow.\nresource: The MBQC resource state.\nvertex: The vertex for which to get the verified flow output.\n\nReturns\n\nIf the flow output is a valid vertex in the neighborhood of the given vertex, it returns the verified flow output.\nIf the flow output is Nothing, it returns nothing.\nIf the flow type is neither ForwardFlow nor BackwardFlow, it throws an error.\n\nExamples\n\nT = ForwardFlow()\nresource = MBQCResourceState(...)\nvertex = 1\noutput = get_verified_flow_output(T, resource, vertex) # Returns the verified flow output for the given vertex\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_vertex_iterator-Tuple{MBQCResourceState}","page":"API","title":"VeriQuEST.get_vertex_iterator","text":"get_vertex_iterator(resource::MBQCResourceState)\n\nRetrieve an iterator over the vertices in an MBQC resource state.\n\nArguments\n\nresource::MBQCResourceState: An MBQC resource state containing the graph representation of the resource.\n\nReturns\n\nAn iterator over the vertices of the resource state's graph.\n\nExamples\n\n# Create an MBQC resource state\ngraph = MBQCGraph(...)\nflow = MBQCFlow(...)\nangles = MBQCAngles(...)\nresource = MBQCResourceState(graph, flow, angles)\n\n# Get the vertex iterator\nvertex_iterator = get_vertex_iterator(resource)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.get_vertex_neighbours-Tuple{MBQCResourceState, Any}","page":"API","title":"VeriQuEST.get_vertex_neighbours","text":"getvertexneighbours(resource::MBQCResourceState, vertex)\n\nRetrieve the neighbors of a given vertex in an MBQC resource state.\n\nArguments\n\nresource::MBQCResourceState: An MBQC resource state containing the graph representation of the resource.\nvertex: The vertex for which to retrieve the neighbors.\n\nReturns\n\nAn array of vertices representing the neighbors of the specified vertex.\n\nExamples\n\n# Create an MBQC resource state\ngraph = MBQCGraph(...)\nflow = MBQCFlow(...)\nangles = MBQCAngles(...)\nresource = MBQCResourceState(graph, flow, angles)\n\n# Get the neighbors of a vertex\nvertex = 1\nneighbors = get_vertex_neighbours(resource, vertex)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.ident_2x2-Tuple{}","page":"API","title":"VeriQuEST.ident_2x2","text":"ident_2x2()\n\nConstructs a 2x2 identity matrix of complex numbers.\n\nReturns\n\nMatrix{Complex{Float64}}: The 2x2 identity matrix.\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.init_measurement_outcomes!-Tuple{Client, Any, MBQCResourceState}","page":"API","title":"VeriQuEST.init_measurement_outcomes!","text":"init_measurement_outcomes!(::Client, mg, resource::MBQCResourceState)\n\nThis function initializes the measurement outcomes in the meta graph for a client in the MBQC model.  It iterates over each vertex in the resource and sets the :outcome property of each vertex in the meta graph to Int64.\n\nArguments\n\n::Client: The Client object.\nmg: The MetaGraph to which the properties will be added.\nresource::MBQCResourceState: The resource containing the graph and its coloring.\n\nReturns\n\nThe updated MetaGraph.\n\nExamples\n\nclient = Client()\nresource = MBQCResourceState(graph)\nmg = MetaGraphs.MetaGraph(resource.graph.graph)\ninit_measurement_outcomes!(client, mg, resource)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.init_outcomes_vector-Tuple{MBQCResourceState}","page":"API","title":"VeriQuEST.init_outcomes_vector","text":"init_outcomes_vector(resource::MBQCResourceState)\n\nInitialize the outcomes vector for a given MBQC resource state.\n\nArguments\n\nresource::MBQCResourceState: The MBQC resource state.\n\nReturns\n\noutcomes_vec::Vector: The initialized outcomes vector.\n\nExample\n\noutcomes_vec = init_outcomes_vector(resource) # Returns the initialized outcomes vector\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.init_plus_phase_state!-Tuple{NoPhase, Any, Any}","page":"API","title":"VeriQuEST.init_plus_phase_state!","text":"init_plus_phase_state!(nophase::NoPhase, qureg, qᵢ)\n\nThis function initializes a quantum state to a superposition state (|+⟩ state) without adding any phase.  It applies a Hadamard gate to the qubit, putting it into a superposition state.\n\nArguments\n\nnophase::NoPhase: The NoPhase object indicating that no phase is to be added.\nqureg: The quantum register containing the qubit.\nqᵢ: The index of the qubit in the quantum register.\n\nExamples\n\nnophase = NoPhase()\nqureg = createQureg(1, env)\nqᵢ = 1\ninit_plus_phase_state!(nophase, qureg, qᵢ)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.init_plus_phase_state!-Tuple{Phase, Any, Any, Any}","page":"API","title":"VeriQuEST.init_plus_phase_state!","text":"init_plus_phase_state!(phase::Phase, qureg, qᵢ, φᵢ)\n\nThis function initializes a quantum state to a superposition state (|+⟩ state) with a specified phase.  It first applies a Hadamard gate to the qubit, putting it into a superposition state.  Then it applies a Z rotation to the qubit, adding the specified phase.\n\nArguments\n\nphase::Phase: The phase object.\nqureg: The quantum register containing the qubit.\nqᵢ: The index of the qubit in the quantum register.\nφᵢ: The phase to be added to the qubit.\n\nExamples\n\nphase = Phase()\nqureg = createQureg(1, env)\nqᵢ = 1\nφᵢ = π/2\ninit_plus_phase_state!(phase, qureg, qᵢ, φᵢ)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.init_qubit-Tuple{DummyQubit}","page":"API","title":"VeriQuEST.init_qubit","text":"init_qubit(::DummyQubit)::Int64\n\nThis function is used to initialize the qubit in the meta graph.  The state is not given, but the bit for the initial state of the dummy qubit is returned.\n\nArguments\n\ndummy::DummyQubit: The DummyQubit object.\n\nReturns\n\nAn Int64 representing the bit for the initial state of the dummy qubit.\n\nExamples\n\njulia dummy = DummyQubit() bit = init_qubit(dummy)`\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.init_qubit-Tuple{TrapQubit}","page":"API","title":"VeriQuEST.init_qubit","text":"init_qubit(::TrapQubit)::Float64\n\nThis function is used to initialize the qubit in the meta graph.  The state is not given, but the angle for the plus phase state for a trap qubit is returned.\n\nArguments\n\ntrap::TrapQubit: The TrapQubit object.\n\nReturns\n\nA Float64 representing the angle for the plus phase state for a trap qubit.\n\nExamples\n\ntrap = TrapQubit()\nangle = init_qubit(trap)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.init_qubit_meta_graph!-Tuple{Client, Any, Any}","page":"API","title":"VeriQuEST.init_qubit_meta_graph!","text":"init_qubit_meta_graph!(::Client, resource, mg)\n\nThis function initializes the qubit meta graph for a client in the MBQC model.  It retrieves the round type from the meta graph and then calls the appropriate  init_qubit_meta_graph! function based on the round type.\n\nArguments\n\n::Client: The Client object.\nresource: The resource containing the graph and its coloring.\nmg: The MetaGraph to which the properties will be added.\n\nExamples\n\nclient = Client()\nresource = MBQCResourceState(graph)\nmg = MetaGraphs.MetaGraph(resource.graph.graph)\nset_prop!(mg, :round_type, ComputationRound())\ninit_qubit_meta_graph!(client, resource, mg)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.init_qubit_meta_graph!-Tuple{Client, ComputationRound, MBQCResourceState, Any}","page":"API","title":"VeriQuEST.init_qubit_meta_graph!","text":"init_qubit_meta_graph!(::Client, ::ComputationRound, resource::MBQCResourceState, mg)\n\nThis function initializes the qubit meta graph for a client in the MBQC model during a computation round.  It sets the secret angle and initial qubit properties for each vertex in the meta graph.\n\nArguments\n\n::Client: The Client object.\n::ComputationRound: The ComputationRound object.\nresource::MBQCResourceState: The resource containing the graph and its coloring.\nmg: The MetaGraph to which the properties will be added.\n\nExamples\n\nclient = Client()\nround = ComputationRound()\nresource = MBQCResourceState(graph)\nmg = MetaGraphs.MetaGraph(resource.graph.graph)\ninit_qubit_meta_graph!(client, round, resource, mg)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.init_qubit_meta_graph!-Tuple{Client, MBQC, MBQCResourceState, Any}","page":"API","title":"VeriQuEST.init_qubit_meta_graph!","text":"init_qubit_meta_graph!(::Client, mbqc::MBQC, resource::MBQCResourceState, mg)\n\nThis function initializes the qubit meta graph for a client in the MBQC model.  It sets the secret angle and initial qubit properties for each vertex in the meta graph.\n\nArguments\n\nclient::Client: The Client object.\nmbqc::MBQC: The MBQC object.\nresource::MBQCResourceState: The resource containing the graph and its coloring.\nmg: The MetaGraph to which the properties will be added.\n\nExamples\n\nclient = Client()\nmbqc = MBQC()\nresource = MBQCResourceState(graph)\nmg = MetaGraphs.MetaGraph(resource.graph.graph)\ninit_qubit_meta_graph!(client, mbqc, resource, mg)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.init_qubit_meta_graph!-Tuple{Client, TestRound, MBQCResourceState, Any}","page":"API","title":"VeriQuEST.init_qubit_meta_graph!","text":"init_qubit_meta_graph!(::Client, ::TestRound, resource::MBQCResourceState, mg)\n\nThis function initializes the qubit meta graph for a client in the MBQC model during a test round.  It sets the initial qubit property for each vertex in the meta graph based on the vertex type.\n\nArguments\n\n::Client: The Client object.\n::TestRound: The TestRound object.\nresource::MBQCResourceState: The resource containing the graph and its coloring.\nmg: The MetaGraph to which the properties will be added.\n\nExamples\n\nclient = Client()\nround = TestRound()\nresource = MBQCResourceState(graph)\nmg = MetaGraphs.MetaGraph(resource.graph.graph)\ninit_qubit_meta_graph!(client, round, resource, mg)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.initialise_blank_quantum_state!-Tuple{Any}","page":"API","title":"VeriQuEST.initialise_blank_quantum_state!","text":"initialise_blank_quantum_state!(quantum_state)\n\nInitialise a blank quantum state.\n\nParameters:\n\nquantum_state: The quantum state to be initialised.\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.initialise_quantum_state_meta_graph!-Tuple{Client, Union{DensityMatrix, StateVector}, Any}","page":"API","title":"VeriQuEST.initialise_quantum_state_meta_graph!","text":"initialise_quantum_state_meta_graph!(::Client, state_type::Union{StateVector,DensityMatrix}, mg)\n\nThis function initializes the quantum state of a meta graph for a client in the MBQC model.  It first creates a quantum environment and a quantum state of the specified type.  Then, for each vertex in the meta graph, it gets the vertex type, vertex IO type, and initial qubit value,  and uses these to initialize the qubit in the quantum state.  Finally, it sets the quantum state as a property of the meta graph.\n\nArguments\n\n::Client: The Client object.\nstate_type::Union{StateVector,DensityMatrix}: The type of quantum state to create.\nmg: The MetaGraph to which the properties will be added.\n\nReturns\n\nThe updated MetaGraph.\n\nExamples\n\nclient = Client()\nmg = MetaGraphs.MetaGraph(graph)\nstate_type = StateVector()\ninitialise_quantum_state_meta_graph!(client, state_type, mg)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.initialise_quantum_state_meta_graph!-Tuple{MBQC, Client, Union{DensityMatrix, StateVector}, Any}","page":"API","title":"VeriQuEST.initialise_quantum_state_meta_graph!","text":"initialise_quantum_state_meta_graph!(mbqc::MBQC, client::Client, state_type::Union{StateVector,DensityMatrix}, mg)\n\nThis function initializes the quantum state of a meta graph for a client in the MBQC model.  It first creates a quantum environment and a quantum state of the specified type.  Then, for each vertex in the meta graph, it gets the vertex type and vertex IO type,  and uses these to initialize the qubit in the quantum state.  Finally, it sets the quantum state as a property of the meta graph.\n\nArguments\n\n::MBQC: The MBQC object.\n::Client: The Client object.\nstate_type::Union{StateVector,DensityMatrix}: The type of quantum state to create.\nmg: The MetaGraph to which the properties will be added.\n\nReturns\n\nThe updated MetaGraph.\n\nExamples\n\nmbqc = MBQC()\nclient = Client()\nmg = MetaGraphs.MetaGraph(graph)\nstate_type = StateVector()\ninitialise_quantum_state_meta_graph!(mbqc, client, state_type, mg)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.initialise_qubit-Tuple{DummyQubit, NoInputQubits, Any, Any, Int64}","page":"API","title":"VeriQuEST.initialise_qubit","text":"initialise_qubit(dummy::DummyQubit, noinput::NoInputQubits, quantum_state, qubit_index, qubit_input_value::Int)\n\nThis function initialises a qubit in a quantum state. If the input value for the qubit is zero, it does nothing.  If the input value is one, it applies a Pauli-X gate to the qubit. If the input value is neither zero nor one,  it throws a DummyQubitZeroOneInitialisationError.\n\nArguments\n\ndummy::DummyQubit: The DummyQubit object.\nnoinput::NoInputQubits: The NoInputQubits object.\nquantum_state: The quantum state containing the qubit.\nqubit_index: The index of the qubit in the quantum state.\nqubit_input_value::Int: The input value for the qubit.\n\nExamples\n\ndummy = DummyQubit()\nnoinput = NoInputQubits()\nquantum_state = createQureg(1, env)\nqubit_index = 1\nqubit_input_value = 0\ninitialise_qubit(dummy, noinput, quantum_state, qubit_index, qubit_input_value)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.initialise_qubit-Tuple{MBQC, Union{ComputationQubit, TrapQubit}, Union{InputQubits, NoInputQubits}, Any, Any}","page":"API","title":"VeriQuEST.initialise_qubit","text":"initialise_qubit(mbqc::MBQC, qubit::Union{ComputationQubit,TrapQubit}, input::Union{InputQubits,InputQubits,NoInputQubits}, quantum_state, qubit_index)\n\nThis function initialises a qubit in a quantum state to a superposition state without adding any phase.  It applies a Hadamard gate to the qubit, putting it into a superposition state.\n\nArguments\n\nmbqc::MBQC: The MBQC object.\nqubit::Union{ComputationQubit,TrapQubit}: The type of the qubit.\ninput::Union{InputQubits,InputQubits,NoInputQubits}: The input object.\nquantum_state: The quantum state containing the qubit.\nqubit_index: The index of the qubit in the quantum state.\n\nExamples\n\nmbqc = MBQC()\nqubit = ComputationQubit()\ninput = InputQubits()\nquantum_state = createQureg(1, env)\nqubit_index = 1\ninitialise_qubit(mbqc, qubit, input, quantum_state, qubit_index)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.initialise_qubit-Tuple{Union{ComputationQubit, TrapQubit}, Union{InputQubits, NoInputQubits}, Any, Any, Float64}","page":"API","title":"VeriQuEST.initialise_qubit","text":"initialise_qubit(qubit::Union{ComputationQubit,TrapQubit}, input::Union{InputQubits,InputQubits,NoInputQubits}, quantum_state, qubit_index, qubit_input_value::Float64)\n\nThis function initialises a qubit in a quantum state with a phase determined by the input value.  If the input value is a float, it initialises the qubit to a superposition state with the input value as the phase.  If the input value is not a float, it throws a QubitFloatPhaseInitialisationError.\n\nArguments\n\nqubit::Union{ComputationQubit,TrapQubit}: The type of the qubit.\ninput::Union{InputQubits,InputQubits,NoInputQubits}: The input object.\nquantum_state: The quantum state containing the qubit.\nqubit_index: The index of the qubit in the quantum state.\nqubit_input_value::Float64: The input value for the qubit, which determines the phase.\n\nExamples\n\nqubit = ComputationQubit()\ninput = InputQubits()\nquantum_state = createQureg(1, env)\nqubit_index = 1\nqubit_input_value = 0.5\ninitialise_qubit(qubit, input, quantum_state, qubit_index, qubit_input_value)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.is_round_OK-Tuple{Any}","page":"API","title":"VeriQuEST.is_round_OK","text":"is_round_OK(trap_results)\n\nChecks if a round is successful by examining the trap results. The function filters out the trap results that are equal to 0 (indicating a failure), and checks if the length of the failed traps is less than 1. If there is at least one failed trap, the function returns false, indicating that the round is not OK.\n\nArguments\n\ntrap_results: An array of trap results.\n\nReturns\n\nBool: true if the round is OK (no failed traps), false otherwise.\n\nExamples\n\ntrap_results = [1, 0, 1]\nround_OK = is_round_OK(trap_results)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.is_vertex_in_graph-Tuple{MBQCResourceState, Int64}","page":"API","title":"VeriQuEST.is_vertex_in_graph","text":"is_vertex_in_graph(resource::MBQCResourceState, vertex::Int64)\n\nCheck if a vertex is present in a graph.\n\nArguments\n\nresource::MBQCResourceState: The MBQC resource state.\nvertex::Int64: The vertex to check.\n\nReturns\n\nBool: true if the vertex is present in the graph, false otherwise.\n\nExample\n\nis_vertex_in_graph(resource, vertex) # Returns true if the vertex is present in the graph, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.is_vertex_in_graph-Tuple{MBQCResourceState, Nothing}","page":"API","title":"VeriQuEST.is_vertex_in_graph","text":"is_vertex_in_graph(resource::MBQCResourceState, novertex::Nothing)\n\nCheck if a vertex is present in the graph.\n\nArguments\n\nresource::MBQCResourceState: The MBQC resource state.\nnovertex::Nothing: The vertex to check.\n\nReturns\n\ntrue if the vertex is present in the graph, false otherwise.\n\nExample\n\nis_vertex_in_graph(resource, novertex) # Returns true if the vertex is present in the graph, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.measure_along_ϕ_basis!-Tuple{Client, Any, Union{Int32, Int64}, Float64}","page":"API","title":"VeriQuEST.measure_along_ϕ_basis!","text":"measure_along_ϕ_basis!(client::Client, ψ, v::Union{Int32,Int64}, ϕ::Float64)\n\nThis function measures a quantum state along a specific basis.  It first applies a Z rotation to the state, then applies a Hadamard gate,  and finally performs a measurement. The basis is determined by the angle ϕ.\n\nArguments\n\nclient::Client: The Client object.\nψ: The quantum state to be measured.\nv::Union{Int32,Int64}: The vertex on which the operations are applied.\nϕ::Float64: The angle determining the basis for measurement.\n\nReturns\n\nThe result of the measurement.\n\nExamples\n\nclient = Client()\nψ = QuantumState()\nv = 1\nϕ = π/4\nmeasure_along_ϕ_basis!(client, ψ, v, ϕ)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.measure_along_ϕ_basis!-Tuple{MaliciousServer, Any, Union{Int32, Int64}, Float64}","page":"API","title":"VeriQuEST.measure_along_ϕ_basis!","text":"measure_along_ϕ_basis!(::MaliciousServer, ψ, v::Union{Int32,Int64}, ϕ::Float64)\n\nPerforms a measurement on a qubit along a specified phase basis in a malicious server context.\n\nArguments\n\n::MaliciousServer: Indicates that this function is used in the context of a malicious server.\nψ::QuEST object: The quantum state to be measured.\nv::Union{Int32,Int64}: The qubit to be measured.\nϕ::Float64: The phase angle defining the basis for measurement.\n\nExamples\n\nψ = createQureg(1, createQuESTEnv())\nv = 1\nϕ = π/4\nmeasure_along_ϕ_basis!(MaliciousServer(), ψ, v, ϕ)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.measure_along_ϕ_basis!-Tuple{Union{Server, NoisyServer}, Any, Union{Int32, Int64}, Float64}","page":"API","title":"VeriQuEST.measure_along_ϕ_basis!","text":"measure_along_ϕ_basis!(::Server,ψ,v,ϕ)\n\nMeasures a qubit in the context of a server.\n\nArguments\n\n::Server: Indicates that this function is used in the context of a server.\nψ: The quantum register in which the qubit is measured.\nv: The index of the qubit to be measured.\nϕ: The angle of the measurement.\n\nExamples\n\nmeasure_along_ϕ_basis!(Server(),ψ,v,ϕ)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.mix_two_density_matrices!-Tuple{Quest, DensityMatrices, Any, Any, Any}","page":"API","title":"VeriQuEST.mix_two_density_matrices!","text":"mix_two_density_matrices!(::Quest,::DensityMatrices,ρ₁,ρ₂,p)\n\nMixes two density matrices with a given probability.\n\nArguments\n\n::Quest: Indicates that this function is used in the context of a Quest environment.\n::DensityMatrices: Indicates that the operation is applied to density matrices.\nρ₁::QuEST density matrix: The first density matrix.\nρ₂::QuEST density matrix: The second density matrix.\np::Float64: The probability of mixing.\n\nExamples\n\nnum_qubits = 2\nquantum_env = createQuESTEnv()\nρ₁ = createDensityQureg(num_qubits, quantum_env)\nρ₂ = createDensityQureg(num_qubits, quantum_env)\np = 0.5\nmix_two_density_matrices!(Quest(),DensityMatrices(),ρ₁,ρ₂,p)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.ok_abort_y-Tuple{}","page":"API","title":"VeriQuEST.ok_abort_y","text":"ok_abort_y()\n\nGenerates a tuple of an array of two float values and an array of two string values \"Abort\" and \"Ok\".\n\nReturns\n\nA tuple of two arrays. The first array contains the float values [0.0, 1.0]. The second array contains the string values [\"Abort\", \"Ok\"].\n\nExamples\n\nvalues = ok_abort_y()\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.phase-Tuple{Any}","page":"API","title":"VeriQuEST.phase","text":"phase(θ)\n\nConstructs a phase gate with the given angle θ.\n\nArguments\n\nθ: The angle of the phase gate.\n\nReturns\n\nA 2x2 complex matrix representing the phase gate.\n\nExamples\n\nphase(π/2)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.plot_verification_results-Tuple{MaliciousServer, Terse, Any, Any, Any}","page":"API","title":"VeriQuEST.plot_verification_results","text":"plot_verification_results(::MaliciousServer, ::Terse, xdata, ydata, label)\n\nGenerates a scatter plot of verification results for a MaliciousServer in a Terse mode. The function creates a figure and an axis, plots the data, adds a legend, and returns the figure.\n\nArguments\n\n::MaliciousServer: An instance of MaliciousServer.\n::Terse: An instance of Terse.\nxdata: An array of x-data for the plot.\nydata: An array of y-data for the plot.\nlabel: A string to be used as the label in the legend.\n\nReturns\n\nA Figure object containing the generated plot.\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.plot_verification_results-Tuple{MaliciousServer, Verbose, Any, Any, Any}","page":"API","title":"VeriQuEST.plot_verification_results","text":"plot_verification_results(::MaliciousServer, ::Verbose, xdata, ydata, label)\n\nGenerates a bar plot of verification results for a MaliciousServer in a Verbose mode. The function normalizes the y-data, creates a figure and an axis, plots the data, adds a legend, and returns the figure.\n\nArguments\n\n::MaliciousServer: An instance of MaliciousServer.\n::Verbose: An instance of Verbose.\nxdata: An array of x-data for the plot.\nydata: An array of y-data for the plot.\nlabel: A string to be used as the label in the legend.\n\nReturns\n\nA Figure object containing the generated plot.\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.produce_initialised_graph-Tuple{Client, Any}","page":"API","title":"VeriQuEST.produce_initialised_graph","text":"produce_initialised_graph(::Client, mg)\n\nThis function produces an initialised graph from a meta graph for a client in the MBQC model.  It simply creates a new graph from the meta graph.\n\nArguments\n\n::Client: The Client object.\nmg: The MetaGraph to be converted into a graph.\n\nReturns\n\nA new Graph created from the MetaGraph.\n\nExamples\n\nclient = Client()\nmg = MetaGraphs.MetaGraph(graph)\nproduce_initialised_graph(client, mg)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.produce_initialised_qureg-Tuple{Client, Any}","page":"API","title":"VeriQuEST.produce_initialised_qureg","text":"produce_initialised_qureg(client::Client, mg)\n\nThis function retrieves the quantum state from a meta graph for a client in the MBQC model.  It uses the get_prop function to get the :quantum_state property from the meta graph.\n\nArguments\n\nclient::Client: The Client object.\nmg: The MetaGraph from which the quantum state will be retrieved.\n\nReturns\n\nThe quantum state of the MetaGraph.\n\nExamples\n\nclient = Client()\nmg = MetaGraphs.MetaGraph(graph)\nproduce_initialised_qureg(client, mg)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.rand_k_0_7-Tuple{}","page":"API","title":"VeriQuEST.rand_k_0_7","text":"rand_k_0_7()\n\nDraw a random integer between 0 and 7, inclusive. This function uses the rand function to randomly select from the range 0:7.\n\nReturns\n\nA random integer between 0 and 7, inclusive.\n\nExamples\n\nrand_k_0_7() # Outputs: An integer between 0 and 7\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.run_computation-Tuple{Any, Any, Any}","page":"API","title":"VeriQuEST.run_computation","text":"run_computation(client_meta_graph, num_qubits_from_server, server_quantum_state)\n\nRuns a computation by creating a new Client instance for each qubit from the server. The function iterates over the number of qubits from the server, updates the client's ϕ, measures along the ϕ basis on the client, updates the measurement on the client, and stores the measurement outcome on the client. The updated client meta graph is returned.\n\nArguments\n\nclient_meta_graph: The client's meta graph.\nnum_qubits_from_server: The number of qubits from the server.\nserver_quantum_state: The quantum state of the server.\n\nReturns\n\nclient_meta_graph: The updated client meta graph.\n\nExamples\n\nclient_meta_graph = create_graph(Client(), 3)\nnum_qubits_from_server = 3\nserver_quantum_state = create_quantum_state(Client(), num_qubits_from_server)\nupdated_client_meta_graph = run_computation(client_meta_graph, num_qubits_from_server, server_quantum_state)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.run_computation-Tuple{Client, MaliciousServer, Vararg{Any, 4}}","page":"API","title":"VeriQuEST.run_computation","text":"run_computation(::Client, ::MaliciousServer, server_resource, client_meta_graph, num_qubits_from_server, server_quantum_state)\n\nRuns a quantum computation in the context of a client interacting with a malicious server. The computation involves updating phase angles, measuring along a specific basis, and storing the measurement outcomes.\n\nArguments\n\n::Client: Indicates that this function is used in the context of a client.\n::MaliciousServer: Indicates that this function is used in the context of a malicious server.\nserver_resource::Dict: A dictionary containing server resources.\nclient_meta_graph::Graph: The client's meta graph.\nnum_qubits_from_server::Int64: The number of qubits received from the server.\nserver_quantum_state::QuEST object: The server's quantum state.\n\nExamples\n\nserver_resource = Dict(\"env\" => create_quantum_env(Server()), \"quantum_state\" => create_qureg(Server(), 3), \"graph\" => create_graph(Server(), 3), \"angles\" => [π/4, π/2, 3π/4])\nclient_meta_graph = create_graph(Client(), 3)\nnum_qubits_from_server = 3\nserver_quantum_state = create_qureg(Server(), 3)\nrun_computation(Client(), MaliciousServer(), server_resource, client_meta_graph, num_qubits_from_server, server_quantum_state)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.run_computation-Tuple{Client, Union{Server, NoisyServer}, Any, Any, Any}","page":"API","title":"VeriQuEST.run_computation","text":"run_computation(client::Client, server::Union{Server,NoisyServer}, client_meta_graph, num_qubits_from_server, server_quantum_state)\n\nRuns a computation on a server from a client's perspective. The function iterates over the number of qubits from the server, updates the client's ϕ, measures along the ϕ basis on the server, updates the measurement on the client, and stores the measurement outcome on the client. The updated client meta graph is returned.\n\nArguments\n\nclient::Client: A Client instance.\nserver::Union{Server,NoisyServer}: A Server or NoisyServer instance.\nclient_meta_graph: The client's meta graph.\nnum_qubits_from_server: The number of qubits from the server.\nserver_quantum_state: The quantum state of the server.\n\nReturns\n\nclient_meta_graph: The updated client meta graph.\n\nExamples\n\nclient = Client()\nserver = NoisyServer(noise_model)\nclient_meta_graph = create_graph(client, 3)\nnum_qubits_from_server = 3\nserver_quantum_state = create_quantum_state(server, num_qubits_from_server)\nupdated_client_meta_graph = run_computation(client, server, client_meta_graph, num_qubits_from_server, server_quantum_state)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.run_mbqc-Tuple{Any}","page":"API","title":"VeriQuEST.run_mbqc","text":"run_mbqc(para)\n\nRuns a Measurement-Based Quantum Computation (MBQC) using the provided parameters. The function creates a UBQC resource, generates a client meta graph, extracts the quantum state from the client meta graph, runs the computation, and gets the output.\n\nArguments\n\npara: A dictionary containing the parameters for the MBQC. It should include the key :state_type.\n\nReturns\n\nThe output of the MBQC, obtained by calling get_output.\n\nExamples\n\npara = (args)::NamedTuple # function specific args\nmbqc_output = run_mbqc(para)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.run_ubqc-Tuple{Any}","page":"API","title":"VeriQuEST.run_ubqc","text":"run_ubqc(para)\n\nRuns a Universal Blind Quantum Computation (UBQC) using the provided parameters. The function creates a UBQC resource, generates a client meta graph, extracts the graph and quantum register (qureg) from the client, creates server resources, runs the computation, and gets the UBQC output.\n\nArguments\n\npara: A dictionary containing the parameters for the UBQC. It should include the key :state_type.\n\nReturns\n\nThe output of the UBQC, obtained by calling get_ubqc_output.\n\nExamples\n\npara = (args)::NamedTuple # function specific args\nubqc_output = run_ubqc(para)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.run_verification-Tuple{Client, MaliciousServer, Vararg{Any, 4}}","page":"API","title":"VeriQuEST.run_verification","text":"run_verification(::Client, ::MaliciousServer, round_types, client_resource, state_type, malicious_angles)\n\nRuns a verification process in the context of a client interacting with a malicious server. The process involves generating a property graph, initializing a graph and a quantum register, creating server resources, running a computation, and initializing a blank quantum state.\n\nArguments\n\n::Client: Indicates that this function is used in the context of a client.\n::MaliciousServer: Indicates that this function is used in the context of a malicious server.\nround_types::Array: An array of round types.\nclient_resource::Dict: A dictionary containing client resources.\nstate_type::Symbol: The type of the quantum state.\nmalicious_angles::Union{Float64,Vector{Float64}}: The angles to be used for malicious behavior.\n\nExamples\n\nround_types = [:round1, :round2, :round3]\nclient_resource = Dict(\"env\" => create_quantum_env(Client()), \"quantum_state\" => create_qureg(Client(), 3), \"graph\" => create_graph(Client(), 3))\nstate_type = :state1\nmalicious_angles = [π/4, π/2, 3π/4]\nrun_verification(Client(), MaliciousServer(), round_types, client_resource, state_type, malicious_angles)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.run_verification-Tuple{Client, NoisyServer, Any, Any, Any}","page":"API","title":"VeriQuEST.run_verification","text":"run_verification(client::Client, server::NoisyServer, round_types, client_resource, state_type)\n\nRuns a verification process between a client and a noisy server. For each round type, it generates a property graph for the client, extracts the graph and quantum register from the client, creates resources for the server, runs the computation, initializes a blank quantum state for the server, and stores the client's meta graph. Returns a list of all client meta graphs.\n\nArguments\n\nclient::Client: A Client instance participating in the verification process.\nserver::NoisyServer: A NoisyServer instance participating in the verification process.\nround_types: The types of rounds to be run in the verification process.\nclient_resource: The resources available to the client.\nstate_type: The type of state used in the verification process.\n\nReturns\n\nArray: An array of client meta graphs for each round type.\n\nExamples\n\nclient = Client()\nserver = NoisyServer(noise_model)\nround_types = [ComputationRound(), TestRound()]\nclient_resource = create_resource(client, client_graph, client_qureg)\nstate_type = :state1\nround_graphs = run_verification(client, server, round_types, client_resource, state_type)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.run_verification-Tuple{Client, Server, Any, Any, Any}","page":"API","title":"VeriQuEST.run_verification","text":"run_verification(::Client, ::Server, round_types, client_resource, state_type)\n\nRuns a verification process between a client and a server. For each round type, the function generates a client meta graph, extracts the graph and quantum register (qureg) from the client, creates server resources, runs a computation, initializes a blank quantum state on the server, and stores the client meta graph in a list. The list of client meta graphs is returned.\n\nArguments\n\n::Client: A Client instance.\n::Server: A Server instance.\nround_types: The types of rounds to run.\nclient_resource: The client's resources.\nstate_type: The type of state.\n\nReturns\n\nArray: An array of client meta graphs.\n\nExamples\n\nround_types = [\"round1\", \"round2\"]\nclient_resource = create_resource(Client())\nstate_type = \"state_type_example\"\nround_graphs = run_verification(Client(), Server(), round_types, client_resource, state_type)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.run_verification_simulator-Tuple{MaliciousServer, Terse, Any, Any}","page":"API","title":"VeriQuEST.run_verification_simulator","text":"run_verification_simulator(::MaliciousServer, ::Terse, para, malicious_angles)\n\nRuns a verification simulator in the context of a malicious server. The simulator involves defining colouring, computing backward flow, creating a graph resource, drawing random rounds, running verification, verifying rounds, and getting mode output.\n\nArguments\n\n::MaliciousServer: Indicates that this function is used in the context of a malicious server.\n::Terse: Indicates that this function is used in a terse mode.\npara::Dict: A dictionary containing parameters for the simulation.\nmalicious_angles::Union{Float64,Vector{Float64}}: The angles to be used for malicious behavior.\n\nExamples\n\npara = Dict(\"input\" => Dict(\"indices\" => [1, 2, 3], \"values\" => [0.5, 0.5, 0.5]), \"output\" => [4, 5, 6], \"graph\" => create_graph(Client(), 3), \"secret_angles\" => [π/4, π/2, 3π/4], \"forward_flow\" => [0.1, 0.2, 0.3], \"total_rounds\" => 10, \"computation_rounds\" => 5, \"state_type\" => :state1)\nmalicious_angles = [π/4, π/2, 3π/4]\nrun_verification_simulator(MaliciousServer(), Terse(), para, malicious_angles)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.run_verification_simulator-Tuple{MaliciousServer, Verbose, Any, Any}","page":"API","title":"VeriQuEST.run_verification_simulator","text":"run_verification_simulator(::MaliciousServer, ::Verbose, para, malicious_angles)\n\nRuns a verification simulator in the context of a malicious server. The simulator involves defining colouring, computing backward flow, creating a graph resource, drawing random rounds, running verification, verifying rounds in both terse and verbose modes, and getting mode output.\n\nArguments\n\n::MaliciousServer: Indicates that this function is used in the context of a malicious server.\n::Verbose: Indicates that this function is used in a verbose mode.\npara::Dict: A dictionary containing parameters for the simulation.\nmalicious_angles::Union{Float64,Vector{Float64}}: The angles to be used for malicious behavior.\n\nExamples\n\npara = Dict(\"input\" => Dict(\"indices\" => [1, 2, 3], \"values\" => [0.5, 0.5, 0.5]), \"output\" => [4, 5, 6], \"graph\" => create_graph(Client(), 3), \"secret_angles\" => [π/4, π/2, 3π/4], \"forward_flow\" => [0.1, 0.2, 0.3], \"total_rounds\" => 10, \"computation_rounds\" => 5, \"state_type\" => :state1)\nmalicious_angles = [π/4, π/2, 3π/4]\nrun_verification_simulator(MaliciousServer(), Verbose(), para, malicious_angles)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.run_verification_simulator-Tuple{NoisyServer, Terse, Any}","page":"API","title":"VeriQuEST.run_verification_simulator","text":"run_verification_simulator(server::NoisyServer, ::Terse, para)\n\nRuns a verification simulator on a NoisyServer. It defines colorings for computation and test rounds, computes the threshold for test rounds, creates a client resource, draws random rounds, runs the verification, verifies the rounds, and gets the mode outcome. Returns a tuple containing the results of the test verification, computation verification, and mode outcome.\n\nArguments\n\nserver::NoisyServer: A NoisyServer instance on which the verification simulator will be run.\n::Terse: A verbosity level for the verification process.\npara: A dictionary containing parameters for the verification process.\n\nReturns\n\nTuple: A tuple containing the results of the test verification (test_verification), computation verification (computation_verification), and mode outcome (mode_outcome).\n\nExamples\n\nserver = NoisyServer(noise_model)\npara = Dict(:graph => create_graph(Client(), 3), :input => Dict(:indices => [1, 2], :values => [0, 1]), :output => [3], :secret_angles => [0.5, 0.5], :forward_flow => [0.5, 0.5], :total_rounds => 10, :computation_rounds => 5, :state_type => :state1)\nresults = run_verification_simulator(server, Terse(), para)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.run_verification_simulator-Tuple{NoisyServer, Verbose, Any}","page":"API","title":"VeriQuEST.run_verification_simulator","text":"run_verification_simulator(server::NoisyServer, ::Verbose, para)\n\nRuns a verification simulator on a NoisyServer with verbose output. It defines colorings for computation and test rounds, computes the threshold for test rounds, creates a client resource, draws random rounds, runs the verification, verifies the rounds in both terse and verbose modes, and gets the mode outcome. Returns a tuple containing the results of the test verification, computation verification, verbose test verification, verbose computation verification, and mode outcome.\n\nArguments\n\nserver::NoisyServer: A NoisyServer instance on which the verification simulator will be run.\n::Verbose: A verbosity level for the verification process.\npara: A dictionary containing parameters for the verification process.\n\nReturns\n\nTuple: A tuple containing the results of the test verification (test_verification), verbose test verification (test_verification_verb), computation verification (computation_verification), verbose computation verification (computation_verification_verb), and mode outcome (mode_outcome).\n\nExamples\n\nserver = NoisyServer(noise_model)\npara = Dict(:graph => create_graph(Client(), 3), :input => Dict(:indices => [1, 2], :values => [0, 1]), :output => [3], :secret_angles => [0.5, 0.5], :forward_flow => [0.5, 0.5], :total_rounds => 10, :computation_rounds => 5, :state_type => :state1)\nresults = run_verification_simulator(server, Verbose(), para)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.run_verification_simulator-Tuple{TrustworthyServer, Terse, Any}","page":"API","title":"VeriQuEST.run_verification_simulator","text":"run_verification_simulator(::TrustworthyServer, ::Terse, para)\n\nRuns a verification simulator for a TrustworthyServer in a Terse mode. The function defines colouring, computes the backward flow, creates a client resource, draws random rounds, runs the verification, verifies the rounds, gets the mode output, and returns the verification results and mode outcome.\n\nArguments\n\n::TrustworthyServer: An instance of TrustworthyServer.\n::Terse: An instance of Terse.\npara: A dictionary containing the parameters for the verification simulator. It should include the keys :graph, :input, :output, :secret_angles, :forward_flow, :total_rounds, and :computation_rounds.\n\nReturns\n\nA tuple containing the test verification result, the computation verification result, and the mode outcome.\n\nExamples\n\npara = (args)::NamedTuple # function specific args\nresult = run_verification_simulator(TrustworthyServer(), Terse(), para)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.run_verification_simulator-Tuple{TrustworthyServer, Verbose, Any}","page":"API","title":"VeriQuEST.run_verification_simulator","text":"run_mbqc(para)\n\nRuns a Measurement-Based Quantum Computation (MBQC) using the provided parameters. The function creates a UBQC resource, generates a client meta graph, extracts the quantum state from the client meta graph, runs the computation, and gets the output.\n\nArguments\n\npara: A NamedTuple containing the parameters for the MBQC.\n\nReturns\n\nThe output of the MBQC, obtained by calling get_output.\n\nExamples\n\npara = (args)::NamedTuple # function specific args\nmbqc_output = run_mbqc(para)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.separate_each_color-Tuple{Graphs.Coloring{Int64}}","page":"API","title":"VeriQuEST.separate_each_color","text":"separate_each_color(g::Graphs.Coloring{Int64})\n\nThis function extracts from a Graphs.Coloring{Int64} and returns a Vector{Vector{Int64}}.  Once a coloring is selected, a vector of integers will result where:\n\n1 represents a Dummy vertex\n2 represents a Trap\n\nArguments\n\ng::Graphs.Coloring{Int64}: The graph coloring object.\n\nExamples\n\njulia g = Graphs.grid_graph((5,5)) coloring = Graphs.greedy_color(g) separate_each_color(coloring)`\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.set_io_qubits_type!-Tuple{Client, Any, Any}","page":"API","title":"VeriQuEST.set_io_qubits_type!","text":"set_io_qubits_type!(::Client, resource, mg)\n\nThis function sets the input/output qubits type property in a MetaGraph based on the round type property of the MetaGraph. \n\nArguments\n\nclient::Client: The Client object.\nresource: The resource containing the graph and its coloring.\nmg: The MetaGraph to which the vertex io type property will be added.\n\nExamples\n\nclient = Client()\nresource = MBQCResourceState(graph)\nmg = MetaGraphs.MetaGraph(resource.graph.graph)\nset_prop!(mg, :round_type, ComputationRound())\nset_io_qubits_type!(client, resource, mg)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.set_io_qubits_type!-Tuple{ComputationRound, Any, Any}","page":"API","title":"VeriQuEST.set_io_qubits_type!","text":"set_io_qubits_type!(::ComputationRound, resource, mg)\n\nIn Computation round, there are sometimes input values for qubits. When this happens, this function will allocate space for them in the property graph.  It assigns the InputQubits type to the vertices that are in the input indices and NoInputQubits to the rest.\n\nArguments\n\nround::ComputationRound: The ComputationRound object.\nresource: The resource containing the graph and its coloring.\nmg: The MetaGraph to which the vertex io type property will be added.\n\nExamples\n\nround = ComputationRound()\nresource = MBQCResourceState(graph)\nmg = MetaGraphs.MetaGraph(resource.graph.graph)\nset_io_qubits_type!(round, resource, mg)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.set_io_qubits_type!-Tuple{MBQC, Any, Any}","page":"API","title":"VeriQuEST.set_io_qubits_type!","text":"set_io_qubits_type!(::MBQC, resource, mg)\n\nThis function sets the input/output qubits type property in a MetaGraph for MBQC with no blind.  It assigns the InputQubits type to the vertices that are in the input indices and NoInputQubits to the rest.\n\nArguments\n\nclient::MBQC: The MBQC client object.\nresource: The resource containing the graph and its coloring.\nmg: The MetaGraph to which the vertex io type property will be added.\n\nExamples\n\nclient = MBQC()\nresource = MBQCResourceState(graph)\nmg = MetaGraphs.MetaGraph(resource.graph.graph)\nset_io_qubits_type!(client, resource, mg)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.set_io_qubits_type!-Tuple{TestRound, Any, Any}","page":"API","title":"VeriQuEST.set_io_qubits_type!","text":"set_io_qubits_type!(::TestRound, resource, mg)\n\nIn Test rounds there is no classical input, but this holder function allows for unilateral call, regardless of round.  It assigns the NoInputQubits type to all the vertices.\n\nArguments\n\nround::TestRound: The TestRound object.\nresource: The resource containing the graph and its coloring.\nmg: The MetaGraph to which the vertex io type property will be added.\n\nExamples\n\nround = TestRound()\nresource = MBQCResourceState(graph)\nmg = MetaGraphs.MetaGraph(resource.graph.graph)\nset_io_qubits_type!(round, resource, mg)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.set_vertex_type!-Tuple{Client, Any, Any}","page":"API","title":"VeriQuEST.set_vertex_type!","text":"set_vertex_type!(::Client, resource, mg)\n\nThis function sets the vertex type property in a MetaGraph based on the round type property of the MetaGraph.  It must be implemented after the round type is implemented.\n\nArguments\n\nclient::Client: The Client object.\nresource: The resource containing the graph and its coloring.\nmg: The MetaGraph to which the vertex type property will be added.\n\nExamples\n\nclient = Client()\nresource = MBQCResourceState(graph)\nmg = MetaGraphs.MetaGraph(resource.graph.graph)\nset_prop!(mg, :round_type, ComputationRound())\nset_vertex_type!(client, resource, mg)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.set_vertex_type!-Tuple{TestRound, Any, Any}","page":"API","title":"VeriQuEST.set_vertex_type!","text":"set_vertex_type!(::TestRound, resource, mg)\n\nThis function sets the vertex type property in a MetaGraph based on a random color pattern from the test round in the resource graph.  It assigns the DummyQubit and TrapQubit types to the vertices according to the color pattern.\n\nArguments\n\ntest_round::TestRound: The TestRound object.\nresource: The resource containing the graph and its coloring.\nmg: The MetaGraph to which the vertex type property will be added.\n\nExamples\n\ntest_round = TestRound()\nresource = MBQCResourceState(graph)\nmg = MetaGraphs.MetaGraph(resource.graph.graph)\nset_vertex_type!(test_round, resource, mg)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.set_vertex_type!-Tuple{Union{ComputationRound, MBQC}, Any, Any}","page":"API","title":"VeriQuEST.set_vertex_type!","text":"set_vertex_type!(::Union{MBQC,ComputationRound}, resource, mg)\n\nThis function sets the vertex type property in a MetaGraph based on the color pattern of the computation round in the resource graph.  It assigns the ComputationQubit type to the vertices according to the color pattern.\n\nArguments\n\nmbqc::Union{MBQC,ComputationRound}: The MBQC or ComputationRound object.\nresource: The resource containing the graph and its coloring.\nmg: The MetaGraph to which the vertex type property will be added.\n\nExamples\n\nmbqc = MBQC()\nresource = MBQCResourceState(graph)\nmg = MetaGraphs.MetaGraph(resource.graph.graph)\nset_vertex_type!(mbqc, resource, mg)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.store_measurement_outcome!-Tuple{Client, Any, Any, Any}","page":"API","title":"VeriQuEST.store_measurement_outcome!","text":"store_measurement_outcome!(client::Client, client_meta_graph, qubit, outcome)\n\nThis function stores the measurement outcome of a specific qubit in the client's meta graph.  It uses the set_p function to set the property in the meta graph.\n\nArguments\n\nclient::Client: The Client object.\nclient_meta_graph: The MetaGraph where the measurement outcome will be stored.\nqubit: The qubit whose measurement outcome is being stored.\noutcome: The measurement outcome to be stored.\n\nReturns\n\nNothing. The function modifies the clientmetagraph in-place.\n\nExamples\n\nclient = Client()\nclient_meta_graph = MetaGraphs.MetaGraph(graph)\nqubit = 1\noutcome = 0\nstore_measurement_outcome!(client, client_meta_graph, qubit, outcome)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.throw_error-Tuple{DimensionMismatchDensityMatrices}","page":"API","title":"VeriQuEST.throw_error","text":"throw_error(::DimensionMismatchDensityMatrices)\n\nThrows an error when density matrices do not have the same dimensions.\n\nExamples\n\nthrow_error(DimensionMismatchDensityMatrices()) # Throws an error with the message \"Density matrices do not have the same dimensions\"\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.throw_error-Tuple{DummyQubitZeroOneInitialisationError}","page":"API","title":"VeriQuEST.throw_error","text":"throw_error(::DummyQubitZeroOneInitialisationError)\n\nThrows an error message when the input qubit value is not an integer 0 or 1.\n\nExamples\n\nthrow_error(DummyQubitZeroOneInitialisationError()) # Throws an error with a specific message\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.throw_error-Tuple{ExceededNumKrausOperators}","page":"API","title":"VeriQuEST.throw_error","text":"throw_error(::ExceededNumKrausOperators)\n\nThrows an error when more Kraus operators were presented than allowed.\n\nExamples\n\nthrow_error(ExceededNumKrausOperators()) # Throws an error with the message \"More Kraus operators were presented than allowed. Check again.\"\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.throw_error-Tuple{OnlySingleQubitNoiseInUseError}","page":"API","title":"VeriQuEST.throw_error","text":"throw_error(::OnlySingleQubitNoiseInUseError)\n\nThrows an error when two qubit or multiple qubit noise is not tested.\n\nExamples\n\nthrow_error(OnlySingleQubitNoiseInUseError()) # Throws an error with the message \"Two qubit or multiple qubit noise is not tested and will not be allowed to run, untill\"\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.throw_error-Tuple{ProbabilityExceedsFifteenSixteensError}","page":"API","title":"VeriQuEST.throw_error","text":"throw_error(::ProbabilityExceedsFifteenSixteensError)\n\nThrows an error when a probability greater than 15/16 is encountered, typically in relation to noise model limitations.\n\nExamples\n\nthrow_error(ProbabilityExceedsFifteenSixteensError()) # Throws an error with the message \"Probability is greater than 15/16 (hint: error thrown in relation to noise model limitations)\"\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.throw_error-Tuple{ProbabilityExceedsNoErrorExceeded}","page":"API","title":"VeriQuEST.throw_error","text":"throw_error(::ProbabilityExceedsNoErrorExceeded)\n\nThrows an error when a probability is greater than no error from 1.\n\nExamples\n\nthrow_error(ProbabilityExceedsNoErrorExceeded()) # Throws an error with the message \"Probability is greater than no error from 1.\"\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.throw_error-Tuple{ProbabilityExceedsOneError}","page":"API","title":"VeriQuEST.throw_error","text":"throw_error(::ProbabilityExceedsOneError)\n\nThrows an error when a probability greater than 1 is encountered.\n\nExamples\n\nthrow_error(ProbabilityExceedsOneError()) # Throws an error with the message \"Probability is greater than 1 (hint: not a probability and threw an error)\"\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.throw_error-Tuple{ProbabilityExceedsOneHalfError}","page":"API","title":"VeriQuEST.throw_error","text":"throw_error(::ProbabilityExceedsOneHalfError)\n\nThrows an error when a probability greater than 1/2 is encountered, typically in relation to noise model limitations.\n\nExamples\n\nthrow_error(ProbabilityExceedsOneHalfError()) # Throws an error with the message \"Probability is greater than 1/2 (hint: error thrown in relation to noise model limitations)\"\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.throw_error-Tuple{ProbabilityExceedsThreeQuartersError}","page":"API","title":"VeriQuEST.throw_error","text":"throw_error(::ProbabilityExceedsThreeQuartersError)\n\nThrows an error when a probability greater than 3/4 is encountered, typically in relation to noise model limitations.\n\nExamples\n\nthrow_error(ProbabilityExceedsThreeQuartersError()) # Throws an error with the message \"Probability is greater than 3/4 (hint: error thrown in relation to noise model limitations)\"\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.throw_error-Tuple{ProbabilityLessThanZeroError}","page":"API","title":"VeriQuEST.throw_error","text":"throw_error(::ProbabilityLessThanZeroError)\n\nThrows an error when a probability less than zero is encountered.\n\nExamples\n\nthrow_error(ProbabilityLessThanZeroError()) # Throws an error with the message \"Probability is less than 0 (hint: not a probability and threw an error)\"\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.throw_error-Tuple{QubitFloatPhaseInitialisationError}","page":"API","title":"VeriQuEST.throw_error","text":"throw_error(::QubitFloatPhaseInitialisationError)\n\nThrows an error message when the input qubit value is not a Float64 for a plus state with a phase.\n\nExamples\n\nthrow_error(QubitFloatPhaseInitialisationError()) # Throws an error with a specific message\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.throw_warning-Tuple{FunctionNotMeantToBeUsed}","page":"API","title":"VeriQuEST.throw_warning","text":"throw_warning(::FunctionNotMeantToBeUsed)\n\nThrows a warning message when a function that is not meant to be used anymore is called.\n\nExamples\n\nthrow_warning(FunctionNotMeantToBeUsed()) # Throws a warning with a specific message\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.throw_warning-Tuple{UntestedKrausFunction}","page":"API","title":"VeriQuEST.throw_warning","text":"throw_warning(::UntestedKrausFunction)\n\nThrows a warning when a Kraus operator is not tested, specifically transalting a pointer index from Julia to C, use at peril till function goes away.\n\nExamples\n\nthrow_warning(UntestedKrausFunction()) # Throws a warning with the message \"Kraus operator is not tested, specifically transalting a pointer index from Julia to C, use at peril till function goes away\"\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.two_pi_x-Tuple{}","page":"API","title":"VeriQuEST.two_pi_x","text":"two_pi_x()\n\nGenerates a tuple of two arrays representing the radian values and their string representations from 0 to 2π with a step of π/4.\n\nReturns\n\nA tuple of two arrays. The first array contains the radian values from 0 to 2π with a step of π/4. The second array contains the string representations of these radian values.\n\nExamples\n\nradians, labels = two_pi_x()\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.update_measurement-Tuple{Client, Any, Any, Any}","page":"API","title":"VeriQuEST.update_measurement","text":"update_measurement(client::Client, q, mg, outcome)\n\nThis function retrieves the round type from the measurement graph and then calls the update_measurement function  with the client, round type, qubit, measurement graph, and outcome as arguments.\n\nArguments\n\nclient::Client: The client for which the measurement is being updated.\nq: The qubit for which the measurement is being updated.\nmg: The measurement graph associated with the computation round.\noutcome: The outcome of the measurement.\n\nReturns\n\nThe result of calling update_measurement with the client, round type, qubit, measurement graph, and outcome.\n\nExamples\n\nclient = Client()\nq = 1\nmg = MeasurementGraph()\noutcome = 0\nupdate_measurement(client, q, mg, outcome)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.update_measurement-Tuple{Client, ComputationRound, Any, Any, Any}","page":"API","title":"VeriQuEST.update_measurement","text":"update_measurement(client::Client, round::ComputationRound, q, mg, outcome)\n\nUpdate the measurement for a given computation round and qubit. The function retrieves the one-time pad integer  associated with the qubit and computes the absolute difference between the outcome and the one-time pad integer.\n\nArguments\n\nclient::Client: The client for which the measurement is being updated.\nround::ComputationRound: The computation round for which the measurement is being updated.\nq: The qubit for which the measurement is being updated.\nmg: The measurement graph associated with the computation round.\noutcome: The outcome of the measurement.\n\nReturns\n\nThe absolute difference between the outcome and the one-time pad integer.\n\nExamples\n\nclient = Client()\nround = ComputationRound()\nq = 1\nmg = MeasurementGraph()\noutcome = 0\nupdate_measurement(client, round, q, mg, outcome)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.update_measurement-Tuple{Client, Union{MBQC, TestRound}, Any, Any, Any}","page":"API","title":"VeriQuEST.update_measurement","text":"update_measurement(client::Client, round::Union{MBQC, TestRound}, q, mg, outcome)\n\nThis function is used in the context of Measurement-Based Quantum Computing (MBQC) or during a test round.  It takes an outcome and simply returns it without making any modifications.\n\nArguments\n\nclient::Client: The client for which the measurement is being updated.\nround::Union{MBQC, TestRound}: Specifies whether the computation round is a part of MBQC or a test round.\nq: The qubit for which the measurement is being updated.\nmg: The measurement graph associated with the computation round.\noutcome: The outcome of the measurement.\n\nReturns\n\nThe same outcome that was passed as an argument.\n\nExamples\n\nclient = Client()\nround = MBQC()\nq = 1\nmg = MeasurementGraph()\noutcome = 0\nupdate_measurement(client, round, q, mg, outcome)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.update_ϕ!-Tuple{ComputationRound, ComputationQubit, InputQubits, Any, Any}","page":"API","title":"VeriQuEST.update_ϕ!","text":"update_ϕ!(::ComputationRound, ::ComputationQubit, ::InputQubits, meta_graph, vertex)\n\nUpdates the ϕ value of a given vertex in the meta_graph during a computation round with a computation qubit and input qubits. The new ϕ value is computed based on several properties of the vertex including its initial qubit, secret angle, classical input, X correction, and Z correction.\n\nArguments\n\n::ComputationRound: Indicates that this function is used during a computation round.\n::ComputationQubit: Indicates that a computation qubit is used.\n::InputQubits: Indicates that there are input qubits.\nmeta_graph: The graph to be updated.\nvertex: The vertex in the graph for which the ϕ value is to be updated.\n\nReturns\n\nThe updated meta_graph.\n\nExamples\n\nupdated_graph = update_ϕ!(ComputationRound(), ComputationQubit(), InputQubits(), meta_graph, vertex) # Updates the ϕ value of the specified vertex in the graph\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.update_ϕ!-Tuple{ComputationRound, ComputationQubit, NoInputQubits, Any, Any}","page":"API","title":"VeriQuEST.update_ϕ!","text":"update_ϕ!(::ComputationRound, ::ComputationQubit, ::NoInputQubits, meta_graph, vertex)\n\nUpdates the ϕ value of a given vertex in the meta_graph during a computation round with a computation qubit and no input qubits. The new ϕ value is computed based on several properties of the vertex including its initial qubit, secret angle, X correction, and Z correction.\n\nArguments\n\n::ComputationRound: Indicates that this function is used during a computation round.\n::ComputationQubit: Indicates that a computation qubit is used.\n::NoInputQubits: Indicates that there are no input qubits.\nmeta_graph: The graph to be updated.\nvertex: The vertex in the graph for which the ϕ value is to be updated.\n\nReturns\n\nThe updated meta_graph.\n\nExamples\n\nupdated_graph = update_ϕ!(ComputationRound(), ComputationQubit(), NoInputQubits(), meta_graph, vertex) # Updates the ϕ value of the specified vertex in the graph\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.update_ϕ!-Tuple{MBQC, ComputationQubit, Union{InputQubits, NoInputQubits}, Any, Any}","page":"API","title":"VeriQuEST.update_ϕ!","text":"update_ϕ!(::MBQC, ::ComputationQubit, qT::Union{NoInputQubits,InputQubits}, meta_graph, vertex)\n\nUpdates the ϕ value of a given vertex in the meta_graph during a computation round in a Measurement-Based Quantum Computing (MBQC) model with a computation qubit and either no input qubits or input qubits. The new ϕ value is computed based on several properties of the vertex including its secret angle, X correction, and Z correction.\n\nArguments\n\n::MBQC: Indicates that this function is used in the MBQC model.\n::ComputationQubit: Indicates that a computation qubit is used.\nqT::Union{NoInputQubits,InputQubits}: Indicates that either no input qubits or input qubits are used.\nmeta_graph: The graph to be updated.\nvertex: The vertex in the graph for which the ϕ value is to be updated.\n\nReturns\n\nThe updated meta_graph.\n\nExamples\n\nupdated_graph = update_ϕ!(MBQC(), ComputationQubit(), NoInputQubits(), meta_graph, vertex) # Updates the ϕ value of the specified vertex in the graph\nupdated_graph = update_ϕ!(MBQC(), ComputationQubit(), InputQubits(), meta_graph, vertex) # Updates the ϕ value of the specified vertex in the graph\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.update_ϕ!-Tuple{TestRound, DummyQubit, NoInputQubits, Any, Any}","page":"API","title":"VeriQuEST.update_ϕ!","text":"update_ϕ!(::TestRound, ::DummyQubit, ::NoInputQubits, meta_graph, vertex)\n\nUpdates the ϕ value of a given vertex in the meta_graph during a test round with a dummy qubit and no input qubits. The new ϕ value is computed based on a randomly drawn θᵥ value.\n\nArguments\n\n::TestRound: Indicates that this function is used during a test round.\n::DummyQubit: Indicates that a dummy qubit is used.\n::NoInputQubits: Indicates that there are no input qubits.\nmeta_graph: The graph to be updated.\nvertex: The vertex in the graph for which the ϕ value is to be updated.\n\nReturns\n\nThe updated meta_graph.\n\nExamples\n\nupdated_graph = update_ϕ!(TestRound(), DummyQubit(), NoInputQubits(), meta_graph, vertex) # Updates the ϕ value of the specified vertex in the graph\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.update_ϕ!-Tuple{TestRound, TrapQubit, NoInputQubits, Any, Any}","page":"API","title":"VeriQuEST.update_ϕ!","text":"update_ϕ!(::TestRound, ::TrapQubit, ::NoInputQubits, meta_graph, vertex)\n\nUpdates the ϕ value of a given vertex in the meta_graph during a test round with a trap qubit and no input qubits. The new ϕ value is computed based on the initial qubit θᵥ and a randomly drawn rᵥ value.\n\nArguments\n\n::TestRound: Indicates that this function is used during a test round.\n::TrapQubit: Indicates that a trap qubit is used.\n::NoInputQubits: Indicates that there are no input qubits.\nmeta_graph: The graph to be updated.\nvertex: The vertex in the graph for which the ϕ value is to be updated.\n\nReturns\n\nThe updated meta_graph.\n\nExamples\n\nupdated_graph = update_ϕ!(TestRound(), TrapQubit(), NoInputQubits(), meta_graph, vertex) # Updates the ϕ value of the specified vertex in the graph\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.verify_round-Tuple{Client, TestRound, Any}","page":"API","title":"VeriQuEST.verify_round","text":"verify_round(::Client, ::TestRound, mg)\n\nVerifies a round of computation from a client's meta graph. The function iterates over the vertices of the meta graph, checks if the vertex type is a TrapQubit, gets the neighbors and properties of the vertex, calculates the verification result, and stores the result in a list. If all results are TrapPass, the function returns 1 (indicating the round is good); otherwise, it returns 0 (indicating the round is bad).\n\nArguments\n\n::Client: A Client instance.\n::TestRound: A TestRound instance.\nmg: The client's meta graph.\n\nReturns\n\nInt: 1 if the round is good, 0 if the round is bad.\n\nExamples\n\nmg = create_meta_graph(Client())\nround_verification = verify_round(Client(), TestRound(), mg)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.verify_rounds-Tuple{Client, ComputationRound, Terse, Any}","page":"API","title":"VeriQuEST.verify_rounds","text":"verify_rounds(::Client, ::ComputationRound, ::Terse, rounds_as_graphs)\n\nVerifies multiple rounds of computation from a list of client's meta graphs. The function counts the number of computation rounds, collects the outputs of the computation rounds, calculates the mode of the outputs, and counts the number of outputs that match the mode. If the number of outputs that match the mode is greater than half the number of computation rounds, the function returns Ok(), otherwise it returns Abort().\n\nArguments\n\n::Client: A Client instance.\n::ComputationRound: A ComputationRound instance.\n::Terse: A Terse instance.\nrounds_as_graphs: A list of client's meta graphs.\n\nReturns\n\nOk or Abort: Ok() if the number of outputs that match the mode is greater than half the number of computation rounds, Abort() otherwise.\n\nExamples\n\nrounds_as_graphs = [create_meta_graph(Client()) for _ in 1:5]\nround_verification = verify_rounds(Client(), ComputationRound(), Terse(), rounds_as_graphs)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.verify_rounds-Tuple{Client, ComputationRound, Verbose, Any}","page":"API","title":"VeriQuEST.verify_rounds","text":"verify_rounds(::Client, ::ComputationRound, ::Verbose, rounds_as_graphs)\n\nVerifies multiple rounds of computation from a list of client's meta graphs. The function counts the number of computation rounds, collects the outputs of the computation rounds, calculates the mode of the outputs, and counts the number of outputs that match the mode. The function then returns a tuple with the number of failed and passed rounds.\n\nArguments\n\n::Client: A Client instance.\n::ComputationRound: A ComputationRound instance.\n::Verbose: A Verbose instance.\nrounds_as_graphs: A list of client's meta graphs.\n\nReturns\n\nTuple: A tuple with the number of failed and passed rounds.\n\nExamples\n\nrounds_as_graphs = [create_meta_graph(Client()) for _ in 1:5]\nround_verification = verify_rounds(Client(), ComputationRound(), Verbose(), rounds_as_graphs)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.verify_rounds-Tuple{Client, TestRound, Terse, Any, Any}","page":"API","title":"VeriQuEST.verify_rounds","text":"verify_rounds(::Client, ::TestRound, ::Terse, rounds_as_graphs, pass_threshold)\n\nVerifies multiple rounds of computation from a list of client's meta graphs. The function iterates over the meta graphs, skips those with a round type of ComputationRound, verifies the round, and stores the outcome in a list. The function then counts the number of failed rounds. If the number of failed rounds is greater than the pass threshold, the function returns Abort(), otherwise it returns Ok().\n\nArguments\n\n::Client: A Client instance.\n::TestRound: A TestRound instance.\n::Terse: A Terse instance.\nrounds_as_graphs: A list of client's meta graphs.\npass_threshold: The threshold for a round to be considered as passed.\n\nReturns\n\nAbort or Ok: Abort() if the number of failed rounds is greater than the pass threshold, Ok() otherwise.\n\nExamples\n\nrounds_as_graphs = [create_meta_graph(Client()) for _ in 1:5]\npass_threshold = 3\nround_verification = verify_rounds(Client(), TestRound(), Terse(), rounds_as_graphs, pass_threshold)\n\n\n\n\n\n","category":"method"},{"location":"references/api/#VeriQuEST.verify_rounds-Tuple{Client, TestRound, Verbose, Any, Any}","page":"API","title":"VeriQuEST.verify_rounds","text":"verify_rounds(::Client, ::TestRound, ::Verbose, rounds_as_graphs, pass_threshold)\n\nVerifies multiple rounds of computation from a list of client's meta graphs. The function iterates over the meta graphs, skips those with a round type of ComputationRound, verifies the round, and stores the outcome in a list. The function then counts the number of failed rounds and returns a tuple with the number of failed and passed rounds.\n\nArguments\n\n::Client: A Client instance.\n::TestRound: A TestRound instance.\n::Verbose: A Verbose instance.\nrounds_as_graphs: A list of client's meta graphs.\npass_threshold: The threshold for a round to be considered as passed.\n\nReturns\n\nTuple: A tuple with the number of failed and passed rounds.\n\nExamples\n\nrounds_as_graphs = [create_meta_graph(Client()) for _ in 1:5]\npass_threshold = 3\nround_verification = verify_rounds(Client(), TestRound(), Verbose(), rounds_as_graphs, pass_threshold)\n\n\n\n\n\n","category":"method"},{"location":"references/api/","page":"API","title":"API","text":"Documentation content assisted with AI from GitHup Copilot.","category":"page"},{"location":"user/quantum_noise/#Quantum-Noise","page":"Notes on Noise","title":"Quantum Noise","text":"","category":"section"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"Modelling quantum noise requires the use of mixed states. The dnesity matrix (DensityMatrix) as opposed to the state vector (StateVector) represented as a Complex matrix and vector respectively is the data backend to use. Pure states, using state vectors output perfect ideal results, making noise modelling limited to post measurement bit flips. Initialising density matrices with QuEST can be done as ","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"env = createQuESTEnv()\nnum_qubits = 10\nqureg = createDensityQureg(num_qubits, env)","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"which creates the pure state  0 rightangleleftangle 0 . By default QuEST has prebuilt decoherence models. These are ","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"Damping\nDephasing\nDepolarising\nPauli \nKraus maps\nDensity matrix mixing","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"Note that some of the above models are available is two qubit and N qubits gates.","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"Set a scaling factor to ensure noise is not randomly chosen above threshold.","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"p_scale = 0.1","category":"page"},{"location":"user/quantum_noise/#Damping","page":"Notes on Noise","title":"Damping","text":"","category":"section"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"To run a damping noise within the verification framework recall","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"# Damping\np = [p_scale*rand() for i in vertices(para[:graph])]\nmodel = Damping(Quest(),SingleQubit(),p)\nserver = NoisyServer(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/quantum_noise/#Example-of-Damping-directly-in-QuEST","page":"Notes on Noise","title":"Example of Damping directly in QuEST","text":"","category":"section"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"Damping noise induces single qubit amplitude decay through the use of two Kraus operators. Take density matrix, rho to represent the qureg. With probability, p amplitudes are damped from the 1 to the 0 state.","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"rho rightarrow K_1rho K_1^dagger + K_2rho K_2^dagger","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"where ","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"K_1 =beginpmatrix 1  0  0  sqrt1-pendpmatrixquadquad K_2 =beginpmatrix 0  sqrtp  0  0endpmatrix","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"The probability is a real probabilits, hence, 0 le p le 1, where p=1 implies the amplitude of the state always damps to the zero state.","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"In QuEST directly this is called as","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"env = createQuESTEnv()\nnum_qubits = 1\nqureg = createDensityQureg(num_qubits,env)","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"The density matrix is","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"2×2 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"apply an X gate","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"pauliX(qureg,1)","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"gives ","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"2×2 Matrix{ComplexF64}:\n 0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"So we are now in the 1 state. Lets apply the damping function.","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"p = .33\nmixDamping(qureg,1,p)","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"gives","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"2×2 Matrix{ComplexF64}:\n 0.33+0.0im   0.0+0.0im\n  0.0+0.0im  0.67+0.0im","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"Note that the function get_qureg_matrix(qureg::Qureg) will return the state vector or density matrix when called. The amplitudes of the 1 state have \"damped\" proportionally to the propbability of the damping function.","category":"page"},{"location":"user/quantum_noise/#Key-takeaways-for-the-damping-decoherence-model","page":"Notes on Noise","title":"Key takeaways for the damping decoherence model","text":"","category":"section"},{"location":"user/quantum_noise/#Dephasing","page":"Notes on Noise","title":"Dephasing","text":"","category":"section"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"To run a dephasing noise within the verification framework recall","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"# Dephasing\np = [p_scale*rand() for i in vertices(para[:graph])]\nmodel = Dephasing(Quest(),SingleQubit(),p)\nserver = NoisyServer(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/quantum_noise/#Example-of-Dephasing-directly-in-QuEST","page":"Notes on Noise","title":"Example of Dephasing directly in QuEST","text":"","category":"section"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"With probability, 0 le p le 12 a Paulia Z gate is mixed with a density matrix qureg, rho to results in a single qubit dephasing noise on qubit, q. ","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"rho rightarrow (1-p)rho +p Z_q rho Z_q","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"We set up a density qureg.","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"env = createQuESTEnv()\nnum_qubits = 1\nqureg = createDensityQureg(num_qubits,env)","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"Get the details of the state","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"2×2 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"Apply a Pauli Y gate,","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"rotateY(qureg,1,π/4)","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"with state details,","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"2×2 Matrix{ComplexF64}:\n 0.853553+0.0im  0.353553+0.0im\n 0.353553+0.0im  0.146447+0.0im","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"then apply a maximally mixed dephasing gate","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"p = 0.5\nmixDephasing(qureg,1,p)","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"with new state now","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"2×2 Matrix{ComplexF64}:\n 0.853553+0.0im       0.0+0.0im\n      0.0+0.0im  0.146447+0.0im","category":"page"},{"location":"user/quantum_noise/#Key-takeaways-for-the-dephasing-decoherence-model","page":"Notes on Noise","title":"Key takeaways for the dephasing decoherence model","text":"","category":"section"},{"location":"user/quantum_noise/#Depolarising","page":"Notes on Noise","title":"Depolarising","text":"","category":"section"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"To run a depolarising noise within the verification framework recall","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"# Depolarising\np = [p_scale*rand() for i in vertices(para[:graph])]\nmodel = Depolarising(Quest(),SingleQubit(),p)\nserver = NoisyServer(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/quantum_noise/#Example-of-depolarising-directly-in-QuEST","page":"Notes on Noise","title":"Example of depolarising directly in QuEST","text":"","category":"section"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"Depolarising noise mixes a density qureg to result in single-qubit homogeneous depolarising noise. Like Dephasing noise, with probability p a uniformly random noise is appied to qubit q. The applied noise is either Pauli X, Y, or Z to q.","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"rho rightarrow (1-p)rho +fracp3 X_q rho X_q + Y_q rho Y_q + Z_q rho Z_q","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"note that p has an upper bound of 34, where maximal mixing occurs and is equivalent to","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"rho rightarrow left(1 - frac43pright)rho + left(frac43p right)fracbar12","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"where fracbar12 is the maximally mixed state of q.","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"In QuEST directly this is called as","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"env = createQuESTEnv()\nnum_qubits = 1\nqureg = createDensityQureg(num_qubits,env)","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"The density matrix is","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"2×2 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"Apply, as before a Y gate,","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"rotateY(qureg,1,π/4)","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"which has state,","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"2×2 Matrix{ComplexF64}:\n 0.853553+0.0im  0.353553+0.0im\n 0.353553+0.0im  0.146447+0.0im","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"then apply a depolarising noise,","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"p = 0.5\nmixDepolarising(qureg,1,p)","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"which has state","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"2×2 Matrix{ComplexF64}:\n0.617851+0.0im  0.117851+0.0im\n0.117851+0.0im  0.382149+0.0im","category":"page"},{"location":"user/quantum_noise/#Key-takeaways-for-the-depolarising-decoherence-model","page":"Notes on Noise","title":"Key takeaways for the depolarising decoherence model","text":"","category":"section"},{"location":"user/quantum_noise/#Pauli","page":"Notes on Noise","title":"Pauli","text":"","category":"section"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"To run a Pauli noise within the verification framework recall","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"# Pauli\np_xyz(p_scale) = p_scale .* [rand(),rand(),rand()]\np = [p_xyz(p_scale) for i in vertices(para[:graph])]\nmodel = Pauli(Quest(),SingleQubit(),p)\nserver = NoisyServer(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"Note that the Pauli probabilities is a vector of three differently drawn values. This is to account of the Xtimes Ytimes Z directions.","category":"page"},{"location":"user/quantum_noise/#Example-of-Pauli-directly-in-QuEST","page":"Notes on Noise","title":"Example of Pauli directly in QuEST","text":"","category":"section"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"In QuEST directly this is called as","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"env = createQuESTEnv()\nnum_qubits = 1\nqureg = createDensityQureg(num_qubits,env)","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"The density matrix is","category":"page"},{"location":"user/quantum_noise/","page":"Notes on Noise","title":"Notes on Noise","text":"2×2 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im","category":"page"},{"location":"user/quantum_noise/#Key-takeaways-for-the-Pauli-decoherence-model","page":"Notes on Noise","title":"Key takeaways for the Pauli decoherence model","text":"","category":"section"},{"location":"#Introduction-to-VeriQuEST.jl","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"","category":"section"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"VeriQuEST.jl is a Julia package emulating a special subset of quantum computation called verification. This is the process of determining if a quantum computation split between at least two parties, traditionaly an \"Alice\" and \"Bob\" client-server model, can be secure. Alice, the client, uses Bob, the server, to complete quantum compuation she can not. Alice does not want Bob to know anything private about her computation. She also wants assurannces that Bob is not malicious nor too noisy. If Bob is either, than Alice wants to know this is the case, then she can choose how to proceed, typically aborting the job.","category":"page"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"Verification relies, among other things, on universal blind quantum computing (UBQC), a subset of the measurement-based quantum computing (MBQC) paradigm. This paradigm, unlike the common \"gate-based\" model, relies on entanglement, mid-circuit measurement and interactive solving to compute. MBQC and UBQC compute algorirthms that are easily represented by a graph of vertices and edges. Each vertex represents a qubit and each edge is an entangling gate. Qubits are measured during the algorithm's execution (e.g., mid-circuit measurement), with outcomes informing measurement basis for future measurements. Security is gauranteed through blindness, the act of hiding specific qubit states by the client from the server. By repeating the same graph multiple times, with the caveat that a secret proportion of repetitions are actually tests to gauge the server, vertification can be ensured. This method is even robust to constant noise by increasing the number of repetitions. Analysis of the repetitions as a whole will yield the trustworthyness, maliciousness and noisyness of Bob.","category":"page"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"Quantum operations are emulated with the QuEST library QuEST's GitHub. QuEST is a C library capable of emulating quantum computation classically, agnostic of most hardware. VeriQuEST uses QuEST.jl to access the C library through QuEST_jll.jl a binary generated with BinaryBuilder.jl.","category":"page"},{"location":"#Package-features","page":"Introduction to VeriQuEST.jl","title":"Package features","text":"","category":"section"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"Features present in the VerifQuEST package:","category":"page"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"Can run standard MBQC algorithms\nCan run UBQC\nVerification emulation in specific conditions:\nIdeal pure states\nMixed noiseless states\nUncorrelated noise\nSingle qubit pre-entanglement noise\n(in development) multiple qubit noise models\n(in development) hardware specific realistic noise models \nNoise models include: damping, dephasing, depolarising, Pauli, density matrix mixing and Kraus maps","category":"page"},{"location":"#Quick-start","page":"Introduction to VeriQuEST.jl","title":"Quick start","text":"","category":"section"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"VeriQuEST is on the general registry.","category":"page"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"using Pkg\nPkg.add(\"VeriQuEST\")","category":"page"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"or","category":"page"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"] add VeriQuEST","category":"page"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"Then, ","category":"page"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"using VeriQuEST","category":"page"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"A generic template, currently these variable names are mandatory.","category":"page"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"# Choose backend and round counts\nstate_type::DensityMatrix = DensityMatrix() #or StateVector\ntotal_rounds::Int = # Number of rounds, 1...N\ncomputation_rounds::Int = # Number of rounds,1,...,N\n\n# Grover graph\nnum_vertices::Int = # Also becomes number of qubits\ngraph = Graph(num_vertices)::Graph # Uses Graphs.jl\n# Specify graph using Graphs.jl API\n\ninput = (indices = (),values = ())::NamedTuple # Input classical data\noutput = ()::Tuple # Output qubits classical outcomes BQP \n\n# Julia is indexed 1, hence a vertex with 0 index is a flag for no flow\nfunction forward_flow(vertex::Int)\n    v_str = string(vertex)\n    forward = Dict(\n        \"current\" =>future,\n        \"1\" => 0) # indicates vertex 1 does not have a flow, specify all qubits. \n    forward[v_str]\nend\n\n\nsecret_angles::Vector{Float64} = # Angles secret from Bob\n\n\n# Keep as is\npara::NamedTuple= (\n    graph=graph,\n    forward_flow = forward_flow,\n    input = input,\n    output = output,\n    secret_angles=secret_angles,\n    state_type = state_type,\n    total_rounds = total_rounds,\n    computation_rounds = computation_rounds)","category":"page"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"This script can be seen as the mandatory configuration used to run all subsequent computations.","category":"page"},{"location":"user/getting_started/#Getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"Recall the generic template to get started.","category":"page"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Choose backend and round counts\nstate_type::DensityMatrix = DensityMatrix() #or StateVector\ntotal_rounds::Int = # Number of rounds, 1...N\ncomputation_rounds::Int = # Number of rounds,1,...,N\n\n# Grover graph\nnum_vertices::Int = # Also becomes number of qubits\ngraph = Graph(num_vertices)::Graph # Uses Graphs.jl\n# Specify graph using Graphs.jl API\n\ninput = (indices = (),values = ())::NamedTuple # Input classical data\noutput = ()::Tuple # Output qubits classical outcomes BQP \n\n# Julia is indexed 1, hence a vertex with 0 index is a flag for no flow\nfunction forward_flow(vertex::Int)\n    v_str = string(vertex)\n    forward = Dict(\n        \"current\" =>future,\n        \"1\" => 0) # indicates vertex 1 does not have a flow, specify all qubits. \n    forward[v_str]\nend\n\n\nsecret_angles::Vector{Float64} = # Angles secret from Bob\n\n\n# Keep as is\npara::NamedTuple= (\n    graph=graph,\n    forward_flow = forward_flow,\n    input = input,\n    output = output,\n    secret_angles=secret_angles,\n    state_type = state_type,\n    total_rounds = total_rounds,\n    computation_rounds = computation_rounds)","category":"page"},{"location":"user/getting_started/#Using-para","page":"Getting Started","title":"Using para","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"The NamedTuple with variable name para is the entry point for all operations developed in this package. ","category":"page"},{"location":"user/getting_started/#Basic-computation","page":"Getting Started","title":"Basic computation","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"To simply run the algorithm, unblinded, then call run_mbqc","category":"page"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"run_mbqc(para)","category":"page"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"and for a blind computation of the same input, then call run_ubqc","category":"page"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"run_ubqc(para)","category":"page"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"Since both are computing the same graph, except that run_ubqc hides the state and both are universal, then the outcome should be the same.","category":"page"},{"location":"user/getting_started/#Verification","page":"Getting Started","title":"Verification","text":"","category":"section"},{"location":"user/getting_started/#Trustworthy","page":"Getting Started","title":"Trustworthy","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"To run the verification of a noiseless and trustworthy server.","category":"page"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"vbqc_outcome = run_verification_simulator(TrustworthyServer(),Verbose(),para)","category":"page"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"Note that additionally to para, there are two type calls, TrustWorthyServer and Verbose. Due to Julia's use of multiple dispatch, algorithms make use of this paradigm. In this case Trustworthy indicates there is no noise and no maliciousness. And the flag Verbose retuns more lengthy result data, as opposed to the Terse type.","category":"page"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"vbqc_outcome = run_verification_simulator(TrustworthyServer(),Terse(),para)","category":"page"},{"location":"user/getting_started/#Malicious","page":"Getting Started","title":"Malicious","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"Here malicious is implemented as an additionaly angle the server adds to each qubit's measurement angle.","category":"page"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"For the Verbose outcome","category":"page"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":" malicious_angles = π/2\nmalicious_vbqc_outcome = run_verification_simulator(MaliciousServer(),Verbose(),para,malicious_angles)","category":"page"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"For the Terse outcome","category":"page"},{"location":"user/getting_started/#Noisyness","page":"Getting Started","title":"Noisyness","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"From QuEST, there are pre-built decoherence emulators.","category":"page"},{"location":"user/getting_started/#Single-qubit","page":"Getting Started","title":"Single qubit","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"Damping, dephasing, depolarising and pauli noise models have been implemented and tested. Note there are also Kraus maps, but testing is in development.","category":"page"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"To run a noisy verification, call the same run_verification_simulaor, but this time the server is a NoisyServer which has a noise model. A noise model is called, which is then passed to the server. The server tells the verification simulator what noise is needed.","category":"page"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"To ensure probabilities are small, a scaling value is applied.","category":"page"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Prob scaling\np_scale = 0.05","category":"page"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"The following examples show how easy it is to insert a pre-made noise model. ","category":"page"},{"location":"user/getting_started/#Damping","page":"Getting Started","title":"Damping","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Damping\np = [p_scale*rand() for i in vertices(para[:graph])]\nmodel = Damping(Quest(),SingleQubit(),p)\nserver = NoisyServer(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/getting_started/#Dephasing","page":"Getting Started","title":"Dephasing","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Dephasing\np = [p_scale*rand() for i in vertices(para[:graph])]\nmodel = Dephasing(Quest(),SingleQubit(),p)\nserver = NoisyServer(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/getting_started/#Depolarising","page":"Getting Started","title":"Depolarising","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Depolarising\np = [p_scale*rand() for i in vertices(para[:graph])]\nmodel = Depolarising(Quest(),SingleQubit(),p)\nserver = NoisyServer(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/getting_started/#Pauli","page":"Getting Started","title":"Pauli","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Pauli\np_xyz(p_scale) = p_scale .* [rand(),rand(),rand()]\np = [p_xyz(p_scale) for i in vertices(para[:graph])]\nmodel = Pauli(Quest(),SingleQubit(),p)\nserver = NoisyServer(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/getting_started/#Vector-of-models","page":"Getting Started","title":"Vector of models","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"    # Vector of noise models\nmodel_vec = [Damping,Dephasing,Depolarising,Pauli]\np_damp = [p_scale*rand() for i in vertices(para[:graph])]\np_deph = [p_scale*rand() for i in vertices(para[:graph])]\np_depo = [p_scale*rand() for i in vertices(para[:graph])]\np_pauli = [p_xyz(p_scale) for i in vertices(para[:graph])]\nprob_vec = [p_damp,p_deph,p_depo,p_pauli]\n\nmodels = Vector{NoiseModels}()\nfor m in eachindex(model_vec)\n    push!(models,model_vec[m](Quest(),SingleQubit(),prob_vec[m]))\nend\nserver = NoisyServer(models)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/getting_started/#Kraus-map","page":"Getting Started","title":"Kraus map","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"This functionality needs to be tested, and a warning will display the untested quality.","category":"page"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"This snippet is an example of how the user will call a single qubit Kraus model. ","category":"page"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Krau\np = # some Kraus operators\nmodel = Kraus(Quest(),SingleQubit(),p)\nserver = NoisyServer(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/getting_started/#Double-qubit","page":"Getting Started","title":"Double qubit","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"Many of the above noise models are also available as pairwise operations. These are not yet ready for production.","category":"page"},{"location":"user/getting_started/#N-Qubit-and-Density-operators","page":"Getting Started","title":"N Qubit and Density operators","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"The Kraus maps can be generalised for N qubit operations. These are not yet ready for production.","category":"page"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"There is also density matrix mixing noise. These are not yet ready for production.","category":"page"},{"location":"user/getting_started/#Data-analysis","page":"Getting Started","title":"Data analysis","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"Once verification is complete, it is helpful to have some sense of the results.","category":"page"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"TO DO: Add examples of statistical/numericalresults","category":"page"},{"location":"user/getting_started/#Hardware-specific","page":"Getting Started","title":"Hardware specific","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting Started","title":"Getting Started","text":"Definitely a future to do.","category":"page"}]
}

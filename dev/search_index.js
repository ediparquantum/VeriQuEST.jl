var documenterSearchIndex = {"docs":
[{"location":"user/grover_example/#Gorver-search-MBQC","page":"Gorver search MBQC","title":"Gorver search MBQC","text":"","category":"section"},{"location":"user/grover_example/","page":"Gorver search MBQC","title":"Gorver search MBQC","text":"Run the following script. The search options can be 00, 01, 10 and 11. The results will be the search.","category":"page"},{"location":"user/grover_example/","page":"Gorver search MBQC","title":"Gorver search MBQC","text":"using VeriQuEST\n\n\nstate_type = DensityMatrix()\ntotal_rounds,computation_rounds = 100,50\n\n# Grover graph\nnum_vertices = 8\ngraph = Graph(num_vertices)\nadd_edge!(graph,1,2)\nadd_edge!(graph,2,3)\nadd_edge!(graph,3,6)\nadd_edge!(graph,6,7)\nadd_edge!(graph,1,4)\nadd_edge!(graph,4,5)\nadd_edge!(graph,5,8)\nadd_edge!(graph,7,8)\n\n\n\ninput = (indices = (),values = ())\noutput = (7,8)\n\n\n# Julia is indexed 1, hence a vertex with 0 index is flag for no flow\nfunction forward_flow(vertex)\n    v_str = string(vertex)\n    forward = Dict(\n        \"1\" =>4,\n        \"2\" =>3,\n        \"3\" =>6,\n        \"4\" =>5,\n        \"5\" =>8,\n        \"6\" =>7,\n        \"7\" =>0,\n        \"8\" =>0)\n    forward[v_str]\nend\n\n\nfunction generate_grover_secret_angles(search::String)\n\n    Dict(\"00\"=>(1.0*π,1.0*π),\"01\"=>(1.0*π,0),\"10\"=>(0,1.0*π),\"11\"=>(0,0)) |>\n    x -> x[search] |>\n    x -> [0,0,1.0*x[1],1.0*x[2],0,0,1.0*π,1.0*π] |>\n    x -> Float64.(x)\nend\n\nsearch = \"11\"\nsecret_angles = generate_grover_secret_angles(search)\n\n\n\npara= (\n    graph=graph,\n    forward_flow = forward_flow,\n    input = input,\n    output = output,\n    secret_angles=secret_angles,\n    state_type = state_type,\n    total_rounds = total_rounds,\n    computation_rounds = computation_rounds)","category":"page"},{"location":"user/grover_example/","page":"Gorver search MBQC","title":"Gorver search MBQC","text":"To run MBQC, UBQC and VBQC","category":"page"},{"location":"user/grover_example/","page":"Gorver search MBQC","title":"Gorver search MBQC","text":"mbqc_outcome = run_mbqc(para)\nubqc_outcome = run_ubqc(para)\nvbqc_outcome = run_verification_simulator(TrustworthyServer(),Verbose(),para)","category":"page"},{"location":"user/grover_example/#Noisy-models-in-verification","page":"Gorver search MBQC","title":"Noisy models in verification","text":"","category":"section"},{"location":"user/grover_example/","page":"Gorver search MBQC","title":"Gorver search MBQC","text":"Set a scaling factor to ensure noise is not randomly chosen above threshold.","category":"page"},{"location":"user/grover_example/","page":"Gorver search MBQC","title":"Gorver search MBQC","text":"p_scale = 0.1","category":"page"},{"location":"user/grover_example/#Damping-noise","page":"Gorver search MBQC","title":"Damping noise","text":"","category":"section"},{"location":"user/grover_example/","page":"Gorver search MBQC","title":"Gorver search MBQC","text":"# Damping\np = [p_scale*rand() for i in vertices(para[:graph])]\nmodel = Damping(SingleQubit(),p)\nserver = NoisyChannel(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/grover_example/#Dephasing-noise","page":"Gorver search MBQC","title":"Dephasing noise","text":"","category":"section"},{"location":"user/grover_example/","page":"Gorver search MBQC","title":"Gorver search MBQC","text":"# Dephasing\np = [p_scale*rand() for i in vertices(para[:graph])]\nmodel = Dephasing(SingleQubit(),p)\nserver = NoisyChannel(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/grover_example/#Depolarising-noise","page":"Gorver search MBQC","title":"Depolarising noise","text":"","category":"section"},{"location":"user/grover_example/","page":"Gorver search MBQC","title":"Gorver search MBQC","text":"# Depolarising\np = [p_scale*rand() for i in vertices(para[:graph])]\nmodel = Depolarising(SingleQubit(),p)\nserver = NoisyChannel(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/grover_example/#Pauli-noise","page":"Gorver search MBQC","title":"Pauli noise","text":"","category":"section"},{"location":"user/grover_example/","page":"Gorver search MBQC","title":"Gorver search MBQC","text":"# Pauli\np_xyz(p_scale) = p_scale .* [rand(),rand(),rand()]\np = [p_xyz(p_scale) for i in vertices(para[:graph])]\nmodel = Pauli(SingleQubit(),p)\nserver = NoisyChannel(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/grover_example/#Vector-of-noise-models","page":"Gorver search MBQC","title":"Vector of noise models","text":"","category":"section"},{"location":"user/grover_example/","page":"Gorver search MBQC","title":"Gorver search MBQC","text":"# Vector of noise models\nmodel_vec = [Damping,Dephasing,Depolarising,Pauli]\np_damp = [p_scale*rand() for i in vertices(para[:graph])]\np_deph = [p_scale*rand() for i in vertices(para[:graph])]\np_depo = [p_scale*rand() for i in vertices(para[:graph])]\np_pauli = [p_xyz(p_scale) for i in vertices(para[:graph])]\nprob_vec = [p_damp,p_deph,p_depo,p_pauli]\n\nmodels = Vector{AbstractNoiseModels}()\nfor m in eachindex(model_vec)\n    push!(models,model_vec[m](SingleQubit(),prob_vec[m]))\nend\nserver = NoisyChannel(models)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"references/api/#Function-API","page":"API","title":"Function API","text":"","category":"section"},{"location":"references/api/","page":"API","title":"API","text":"Documention generated automatically with @audotdocs. ","category":"page"},{"location":"references/api/","page":"API","title":"API","text":"Docs for package","category":"page"},{"location":"references/api/","page":"API","title":"API","text":"Modules = [VeriQuEST]\nOrder   = [:type, :constant, :macro, :function,]","category":"page"},{"location":"references/api/","page":"API","title":"API","text":"Documentation content assisted with AI from GitHup Copilot.","category":"page"},{"location":"user/quantum_noise/#Quantum-Noise","page":"Quantum Noise","title":"Quantum Noise","text":"","category":"section"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"Modelling quantum noise requires the use of mixed states. The dnesity matrix (DensityMatrix) as opposed to the state vector (StateVector) represented as a Complex matrix and vector respectively is the data backend to use. Pure states, using state vectors output perfect ideal results, making noise modelling limited to post measurement bit flips. Initialising density matrices with QuEST can be done as ","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"env = createQuESTEnv()\nnum_qubits = 10\nqureg = createDensityQureg(num_qubits, env)","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"which creates the pure state  0 rightangleleftangle 0 . By default QuEST has prebuilt decoherence models. These are ","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"Damping\nDephasing\nDepolarising\nPauli \nKraus maps\nDensity matrix mixing","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"Note that some of the above models are available is two qubit and N qubits gates.","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"Set a scaling factor to ensure noise is not randomly chosen above threshold.","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"p_scale = 0.1","category":"page"},{"location":"user/quantum_noise/#Damping","page":"Quantum Noise","title":"Damping","text":"","category":"section"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"To run a damping noise within the verification framework recall","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"# Damping\np = [p_scale*rand() for i in vertices(para[:graph])]\nmodel = Damping(SingleQubit(),p)\nserver = NoisyChannel(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/quantum_noise/#Example-of-Damping-directly-in-QuEST","page":"Quantum Noise","title":"Example of Damping directly in QuEST","text":"","category":"section"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"Damping noise induces single qubit amplitude decay through the use of two Kraus operators. Take density matrix, rho to represent the qureg. With probability, p amplitudes are damped from the 1 to the 0 state.","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"rho rightarrow K_1rho K_1^dagger + K_2rho K_2^dagger","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"where ","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"K_1 =beginpmatrix 1  0  0  sqrt1-pendpmatrixquadquad K_2 =beginpmatrix 0  sqrtp  0  0endpmatrix","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"The probability is a real probabilits, hence, 0 le p le 1, where p=1 implies the amplitude of the state always damps to the zero state.","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"In QuEST directly this is called as","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"env = createQuESTEnv()\nnum_qubits = 1\nqureg = createDensityQureg(num_qubits,env)","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"The density matrix is","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"2×2 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"apply an X gate","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"pauliX(qureg,1)","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"gives ","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"2×2 Matrix{ComplexF64}:\n 0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"So we are now in the 1 state. Lets apply the damping function.","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"p = .33\nmixDamping(qureg,1,p)","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"gives","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"2×2 Matrix{ComplexF64}:\n 0.33+0.0im   0.0+0.0im\n  0.0+0.0im  0.67+0.0im","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"Note that the function get_qureg_matrix(qureg::Qureg) will return the state vector or density matrix when called. The amplitudes of the 1 state have \"damped\" proportionally to the propbability of the damping function.","category":"page"},{"location":"user/quantum_noise/#Key-takeaways-for-the-damping-decoherence-model","page":"Quantum Noise","title":"Key takeaways for the damping decoherence model","text":"","category":"section"},{"location":"user/quantum_noise/#Dephasing","page":"Quantum Noise","title":"Dephasing","text":"","category":"section"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"To run a dephasing noise within the verification framework recall","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"# Dephasing\np = [p_scale*rand() for i in vertices(para[:graph])]\nmodel = Dephasing(SingleQubit(),p)\nserver = NoisyChannel(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/quantum_noise/#Example-of-Dephasing-directly-in-QuEST","page":"Quantum Noise","title":"Example of Dephasing directly in QuEST","text":"","category":"section"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"With probability, 0 le p le 12 a Paulia Z gate is mixed with a density matrix qureg, rho to results in a single qubit dephasing noise on qubit, q. ","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"rho rightarrow (1-p)rho +p Z_q rho Z_q","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"We set up a density qureg.","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"env = createQuESTEnv()\nnum_qubits = 1\nqureg = createDensityQureg(num_qubits,env)","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"Get the details of the state","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"2×2 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"Apply a Pauli Y gate,","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"rotateY(qureg,1,π/4)","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"with state details,","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"2×2 Matrix{ComplexF64}:\n 0.853553+0.0im  0.353553+0.0im\n 0.353553+0.0im  0.146447+0.0im","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"then apply a maximally mixed dephasing gate","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"p = 0.5\nmixDephasing(qureg,1,p)","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"with new state now","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"2×2 Matrix{ComplexF64}:\n 0.853553+0.0im       0.0+0.0im\n      0.0+0.0im  0.146447+0.0im","category":"page"},{"location":"user/quantum_noise/#Key-takeaways-for-the-dephasing-decoherence-model","page":"Quantum Noise","title":"Key takeaways for the dephasing decoherence model","text":"","category":"section"},{"location":"user/quantum_noise/#Depolarising","page":"Quantum Noise","title":"Depolarising","text":"","category":"section"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"To run a depolarising noise within the verification framework recall","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"# Depolarising\np = [p_scale*rand() for i in vertices(para[:graph])]\nmodel = Depolarising(SingleQubit(),p)\nserver = NoisyChannel(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/quantum_noise/#Example-of-depolarising-directly-in-QuEST","page":"Quantum Noise","title":"Example of depolarising directly in QuEST","text":"","category":"section"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"Depolarising noise mixes a density qureg to result in single-qubit homogeneous depolarising noise. Like Dephasing noise, with probability p a uniformly random noise is appied to qubit q. The applied noise is either Pauli X, Y, or Z to q.","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"rho rightarrow (1-p)rho +fracp3 X_q rho X_q + Y_q rho Y_q + Z_q rho Z_q","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"note that p has an upper bound of 34, where maximal mixing occurs and is equivalent to","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"rho rightarrow left(1 - frac43pright)rho + left(frac43p right)fracbar12","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"where fracbar12 is the maximally mixed state of q.","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"In QuEST directly this is called as","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"env = createQuESTEnv()\nnum_qubits = 1\nqureg = createDensityQureg(num_qubits,env)","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"The density matrix is","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"2×2 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"Apply, as before a Y gate,","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"rotateY(qureg,1,π/4)","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"which has state,","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"2×2 Matrix{ComplexF64}:\n 0.853553+0.0im  0.353553+0.0im\n 0.353553+0.0im  0.146447+0.0im","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"then apply a depolarising noise,","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"p = 0.5\nmixDepolarising(qureg,1,p)","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"which has state","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"2×2 Matrix{ComplexF64}:\n0.617851+0.0im  0.117851+0.0im\n0.117851+0.0im  0.382149+0.0im","category":"page"},{"location":"user/quantum_noise/#Key-takeaways-for-the-depolarising-decoherence-model","page":"Quantum Noise","title":"Key takeaways for the depolarising decoherence model","text":"","category":"section"},{"location":"user/quantum_noise/#Pauli","page":"Quantum Noise","title":"Pauli","text":"","category":"section"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"To run a Pauli noise within the verification framework recall","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"# Pauli\np_xyz(p_scale) = p_scale .* [rand(),rand(),rand()]\np = [p_xyz(p_scale) for i in vertices(para[:graph])]\nmodel = Pauli(SingleQubit(),p)\nserver = NoisyChannel(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"Note that the Pauli probabilities is a vector of three differently drawn values. This is to account of the Xtimes Ytimes Z directions.","category":"page"},{"location":"user/quantum_noise/#Example-of-Pauli-directly-in-QuEST","page":"Quantum Noise","title":"Example of Pauli directly in QuEST","text":"","category":"section"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"In QuEST directly this is called as","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"env = createQuESTEnv()\nnum_qubits = 1\nqureg = createDensityQureg(num_qubits,env)","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"The density matrix is","category":"page"},{"location":"user/quantum_noise/","page":"Quantum Noise","title":"Quantum Noise","text":"2×2 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im","category":"page"},{"location":"user/quantum_noise/#Key-takeaways-for-the-Pauli-decoherence-model","page":"Quantum Noise","title":"Key takeaways for the Pauli decoherence model","text":"","category":"section"},{"location":"#Introduction-to-VeriQuEST.jl","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"","category":"section"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"VeriQuEST.jl is a Julia package emulating a special subset of quantum computation called verification. This is the process of determining if a quantum computation split between at least two parties, traditionaly an \"Alice\" and \"Bob\" client-server model, can be secure. Alice, the client, uses Bob, the server, to complete quantum compuation she can not. Alice does not want Bob to know anything private about her computation. She also wants assurannces that Bob is not malicious nor too noisy. If Bob is either, than Alice wants to know this is the case, then she can choose how to proceed, typically aborting the job.","category":"page"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"Verification relies, among other things, on universal blind quantum computing (UBQC), a subset of the measurement-based quantum computing (MBQC) paradigm. This paradigm, unlike the common \"gate-based\" model, relies on entanglement, mid-circuit measurement and interactive solving to compute. MBQC and UBQC compute algorirthms that are easily represented by a graph of vertices and edges. Each vertex represents a qubit and each edge is an entangling gate. Qubits are measured during the algorithm's execution (e.g., mid-circuit measurement), with outcomes informing measurement basis for future measurements. Security is gauranteed through blindness, the act of hiding specific qubit states by the client from the server. By repeating the same graph multiple times, with the caveat that a secret proportion of repetitions are actually tests to gauge the server, vertification can be ensured. This method is even robust to constant noise by increasing the number of repetitions. Analysis of the repetitions as a whole will yield the trustworthyness, maliciousness and noisyness of Bob.","category":"page"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"Quantum operations are emulated with the QuEST library QuEST's GitHub. QuEST is a C library capable of emulating quantum computation classically, agnostic of most hardware. VeriQuEST uses QuEST.jl to access the C library through QuEST_jll.jl a binary generated with BinaryBuilder.jl.","category":"page"},{"location":"#Package-features","page":"Introduction to VeriQuEST.jl","title":"Package features","text":"","category":"section"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"Features present in the VerifQuEST package:","category":"page"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"Can run standard MBQC algorithms\nCan run UBQC\nVerification emulation in specific conditions:\nIdeal pure states\nMixed noiseless states\nUncorrelated noise\nSingle qubit pre-entanglement noise\n(in development) multiple qubit noise models\n(in development) hardware specific realistic noise models \nNoise models include: damping, dephasing, depolarising, Pauli, density matrix mixing and Kraus maps","category":"page"},{"location":"#Quick-start","page":"Introduction to VeriQuEST.jl","title":"Quick start","text":"","category":"section"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"VeriQuEST is on the general registry.","category":"page"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"using Pkg\nPkg.add(\"VeriQuEST\")","category":"page"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"or","category":"page"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"] add VeriQuEST","category":"page"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"Then, ","category":"page"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"using VeriQuEST","category":"page"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"A generic template, currently these variable names are mandatory.","category":"page"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"\n    # Set up input values\n    graph = Graph(2)\n    add_edge!(graph,1,2)\n\n\n    io = InputOutput(Inputs(),Outputs(2))\n    qgraph = QuantumGraph(graph,io)\n    function forward_flow(vertex)\n        v_str = string(vertex)\n        forward = Dict(\n            \"1\" =>2,\n            \"2\"=>0)\n        forward[v_str]\n    end\n    flow = Flow(forward_flow)\n    measurement_angles = Angles([π/2,π/2])\n    total_rounds = 10\n    computation_rounds = 1\n    trapification_strategy = TestRoundTrapAndDummycolouring()\n\n\n\n    # Initial setups\n    ct = LeichtleVerification(\n        total_rounds,\n        computation_rounds,\n        trapification_strategy,\n        qgraph,flow,measurement_angles)\n    nt_bp = BellPairExplicitNetwork()\n    nt_im = ImplicitNetworkEmulation()\n    st = DensityMatrix()\n    ch = NoisyChannel(NoNoise(NoQubits()))\n\n\n    ver_res1 = run_verification_simulator(ct,nt_bp,st,ch)\n    get_tests(ver_res1) \n    get_computations(ver_res1)\n    get_tests_verbose(ver_res1)\n    get_computations_verbose(ver_res1) \n    get_computations_mode(ver_res1) \n\n    ver_res2 = run_verification_simulator(ct,nt_im,st,ch)\n    get_tests(ver_res2) \n    get_computations(ver_res2)\n    get_tests_verbose(ver_res2)\n    get_computations_verbose(ver_res2) \n    get_computations_mode(ver_res2) \n","category":"page"},{"location":"","page":"Introduction to VeriQuEST.jl","title":"Introduction to VeriQuEST.jl","text":"This script can be seen as the mandatory configuration used to run all subsequent computations.","category":"page"},{"location":"user/getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"Recall the generic template to get started.","category":"page"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"# Choose backend and round counts\nstate_type::DensityMatrix = DensityMatrix() #or StateVector\ntotal_rounds::Int = # Number of rounds, 1...N\ncomputation_rounds::Int = # Number of rounds,1,...,N\n\n# Grover graph\nnum_vertices::Int = # Also becomes number of qubits\ngraph = Graph(num_vertices)::Graph # Uses Graphs.jl\n# Specify graph using Graphs.jl API\n\ninput = (indices = (),values = ())::NamedTuple # Input classical data\noutput = ()::Tuple # Output qubits classical outcomes BQP \n\n# Julia is indexed 1, hence a vertex with 0 index is a flag for no flow\nfunction forward_flow(vertex::Int)\n    v_str = string(vertex)\n    forward = Dict(\n        \"current\" =>future,\n        \"1\" => 0) # indicates vertex 1 does not have a flow, specify all qubits. \n    forward[v_str]\nend\n\n\nsecret_angles::Vector{Float64} = # Angles secret from Bob\n\n\n# Keep as is\npara::NamedTuple= (\n    graph=graph,\n    forward_flow = forward_flow,\n    input = input,\n    output = output,\n    secret_angles=secret_angles,\n    state_type = state_type,\n    total_rounds = total_rounds,\n    computation_rounds = computation_rounds)","category":"page"},{"location":"user/getting_started/#Using-para","page":"Getting started","title":"Using para","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"The NamedTuple with variable name para is the entry point for all operations developed in this package. ","category":"page"},{"location":"user/getting_started/#Basic-computation","page":"Getting started","title":"Basic computation","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"To simply run the algorithm, unblinded, then call run_mbqc","category":"page"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"run_mbqc(para)","category":"page"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"and for a blind computation of the same input, then call run_ubqc","category":"page"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"run_ubqc(para)","category":"page"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"Since both are computing the same graph, except that run_ubqc hides the state and both are universal, then the outcome should be the same.","category":"page"},{"location":"user/getting_started/#Verification","page":"Getting started","title":"Verification","text":"","category":"section"},{"location":"user/getting_started/#Trustworthy","page":"Getting started","title":"Trustworthy","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"To run the verification of a noiseless and trustworthy server.","category":"page"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"vbqc_outcome = run_verification_simulator(TrustworthyServer(),Verbose(),para)","category":"page"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"Note that additionally to para, there are two type calls, TrustWorthyServer and Verbose. Due to Julia's use of multiple dispatch, algorithms make use of this paradigm. In this case Trustworthy indicates there is no noise and no maliciousness. And the flag Verbose retuns more lengthy result data, as opposed to the Terse type.","category":"page"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"vbqc_outcome = run_verification_simulator(TrustworthyServer(),Terse(),para)","category":"page"},{"location":"user/getting_started/#Malicious","page":"Getting started","title":"Malicious","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"Here malicious is implemented as an additionaly angle the server adds to each qubit's measurement angle.","category":"page"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"For the Verbose outcome","category":"page"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":" malicious_angles = π/2\nmalicious_vbqc_outcome = run_verification_simulator(MaliciousServer(),Verbose(),para,malicious_angles)","category":"page"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"For the Terse outcome","category":"page"},{"location":"user/getting_started/#Noisyness","page":"Getting started","title":"Noisyness","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"From QuEST, there are pre-built decoherence emulators.","category":"page"},{"location":"user/getting_started/#Single-qubit","page":"Getting started","title":"Single qubit","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"Damping, dephasing, depolarising and pauli noise models have been implemented and tested. Note there are also Kraus maps, but testing is in development.","category":"page"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"To run a noisy verification, call the same run_verification_simulaor, but this time the server is a NoisyChannel which has a noise model. A noise model is called, which is then passed to the server. The server tells the verification simulator what noise is needed.","category":"page"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"To ensure probabilities are small, a scaling value is applied.","category":"page"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"# Prob scaling\np_scale = 0.05","category":"page"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"The following examples show how easy it is to insert a pre-made noise model. ","category":"page"},{"location":"user/getting_started/#Damping","page":"Getting started","title":"Damping","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"# Damping\np = [p_scale*rand() for i in vertices(para[:graph])]\nmodel = Damping(SingleQubit(),p)\nserver = NoisyChannel(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/getting_started/#Dephasing","page":"Getting started","title":"Dephasing","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"# Dephasing\np = [p_scale*rand() for i in vertices(para[:graph])]\nmodel = Dephasing(SingleQubit(),p)\nserver = NoisyChannel(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/getting_started/#Depolarising","page":"Getting started","title":"Depolarising","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"# Depolarising\np = [p_scale*rand() for i in vertices(para[:graph])]\nmodel = Depolarising(SingleQubit(),p)\nserver = NoisyChannel(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/getting_started/#Pauli","page":"Getting started","title":"Pauli","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"# Pauli\np_xyz(p_scale) = p_scale .* [rand(),rand(),rand()]\np = [p_xyz(p_scale) for i in vertices(para[:graph])]\nmodel = Pauli(SingleQubit(),p)\nserver = NoisyChannel(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/getting_started/#Vector-of-models","page":"Getting started","title":"Vector of models","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"    # Vector of noise models\nmodel_vec = [Damping,Dephasing,Depolarising,Pauli]\np_damp = [p_scale*rand() for i in vertices(para[:graph])]\np_deph = [p_scale*rand() for i in vertices(para[:graph])]\np_depo = [p_scale*rand() for i in vertices(para[:graph])]\np_pauli = [p_xyz(p_scale) for i in vertices(para[:graph])]\nprob_vec = [p_damp,p_deph,p_depo,p_pauli]\n\nmodels = Vector{AbstractNoiseModels}()\nfor m in eachindex(model_vec)\n    push!(models,model_vec[m](SingleQubit(),prob_vec[m]))\nend\nserver = NoisyChannel(models)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/getting_started/#Kraus-map","page":"Getting started","title":"Kraus map","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"This functionality needs to be tested, and a warning will display the untested quality.","category":"page"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"This snippet is an example of how the user will call a single qubit Kraus model. ","category":"page"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"# Krau\np = # some Kraus operators\nmodel = Kraus(SingleQubit(),p)\nserver = NoisyChannel(model)\nvbqc_outcome = run_verification_simulator(server,Verbose(),para)","category":"page"},{"location":"user/getting_started/#Double-qubit","page":"Getting started","title":"Double qubit","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"Many of the above noise models are also available as pairwise operations. These are not yet ready for production.","category":"page"},{"location":"user/getting_started/#N-Qubit-and-Density-operators","page":"Getting started","title":"N Qubit and Density operators","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"The Kraus maps can be generalised for N qubit operations. These are not yet ready for production.","category":"page"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"There is also density matrix mixing noise. These are not yet ready for production.","category":"page"},{"location":"user/getting_started/#Data-analysis","page":"Getting started","title":"Data analysis","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"Once verification is complete, it is helpful to have some sense of the results.","category":"page"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"TO DO: Add examples of statistical/numericalresults","category":"page"},{"location":"user/getting_started/#Hardware-specific","page":"Getting started","title":"Hardware specific","text":"","category":"section"},{"location":"user/getting_started/","page":"Getting started","title":"Getting started","text":"Definitely a future to do.","category":"page"}]
}

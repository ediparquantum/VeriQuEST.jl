<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Notes on Noise · VeriQuEST.jl</title><meta name="title" content="Notes on Noise · VeriQuEST.jl"/><meta property="og:title" content="Notes on Noise · VeriQuEST.jl"/><meta property="twitter:title" content="Notes on Noise · VeriQuEST.jl"/><meta name="description" content="Documentation for VeriQuEST.jl."/><meta property="og:description" content="Documentation for VeriQuEST.jl."/><meta property="twitter:description" content="Documentation for VeriQuEST.jl."/><meta property="og:url" content="https://fieldofnodes.github.io/VeriQuEST.jl/user/quantum_noise/"/><meta property="twitter:url" content="https://fieldofnodes.github.io/VeriQuEST.jl/user/quantum_noise/"/><link rel="canonical" href="https://fieldofnodes.github.io/VeriQuEST.jl/user/quantum_noise/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">VeriQuEST.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction to VeriQuEST.jl</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Notes on Noise</a><ul class="internal"><li><a class="tocitem" href="#Damping"><span>Damping</span></a></li><li><a class="tocitem" href="#Dephasing"><span>Dephasing</span></a></li><li><a class="tocitem" href="#Depolarising"><span>Depolarising</span></a></li><li><a class="tocitem" href="#Pauli"><span>Pauli</span></a></li></ul></li><li><a class="tocitem" href="../grover_example/">Grover example</a></li></ul></li><li><span class="tocitem">References</span><ul><li><a class="tocitem" href="../../references/api/">API</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Notes on Noise</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Notes on Noise</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/fieldofnodes/VeriQuEST.jl/blob/main/docs/src/user/quantum_noise.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Quantum-Noise"><a class="docs-heading-anchor" href="#Quantum-Noise">Quantum Noise</a><a id="Quantum-Noise-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Noise" title="Permalink"></a></h1><p>Modelling quantum noise requires the use of mixed states. The dnesity matrix (<code>DensityMatrix</code>) as opposed to the state vector (<code>StateVector</code>) represented as a <code>Complex</code> matrix and vector respectively is the data backend to use. Pure states, using state vectors output perfect ideal results, making noise modelling limited to post measurement bit flips. Initialising density matrices with <code>QuEST</code> can be done as </p><pre><code class="language-julia hljs">env = createQuESTEnv()
num_qubits = 10
qureg = createDensityQureg(num_qubits, env)</code></pre><p>which creates the pure state <span>$| 0 \rightangle\leftangle 0 |$</span>. By default <code>QuEST</code> has prebuilt decoherence models. These are </p><ol><li>Damping</li><li>Dephasing</li><li>Depolarising</li><li>Pauli </li><li>Kraus maps</li><li>Density matrix mixing</li></ol><p>Note that some of the above models are available is two qubit and <span>$N$</span> qubits gates.</p><p>Set a scaling factor to ensure noise is not randomly chosen above threshold.</p><pre><code class="language-julia hljs">p_scale = 0.1</code></pre><h2 id="Damping"><a class="docs-heading-anchor" href="#Damping">Damping</a><a id="Damping-1"></a><a class="docs-heading-anchor-permalink" href="#Damping" title="Permalink"></a></h2><p>To run a damping noise within the verification framework recall</p><pre><code class="language-julia hljs"># Damping
p = [p_scale*rand() for i in vertices(para[:graph])]
model = Damping(Quest(),SingleQubit(),p)
server = NoisyServer(model)
vbqc_outcome = run_verification_simulator(server,Verbose(),para)</code></pre><h3 id="Example-of-Damping-directly-in-QuEST"><a class="docs-heading-anchor" href="#Example-of-Damping-directly-in-QuEST">Example of Damping directly in QuEST</a><a id="Example-of-Damping-directly-in-QuEST-1"></a><a class="docs-heading-anchor-permalink" href="#Example-of-Damping-directly-in-QuEST" title="Permalink"></a></h3><p>Damping noise induces single qubit amplitude decay through the use of two Kraus operators. Take density matrix, <span>$\rho$</span> to represent the qureg. With probability, <span>$p$</span> amplitudes are damped from the <span>$1$</span> to the <span>$0$</span> state.</p><p class="math-container">\[\rho \rightarrow K_1\rho K_1^{\dagger} + K_2\rho K_2^{\dagger}\]</p><p>where </p><p class="math-container">\[K_1 =\begin{pmatrix} 1 &amp; 0 \\ 0 &amp; \sqrt{1-p}\end{pmatrix}\quad\quad K_2 =\begin{pmatrix} 0 &amp; \sqrt{p} \\ 0 &amp; 0\end{pmatrix}\]</p><p>The probability is a real probabilits, hence, <span>$0 \le p \le 1$</span>, where <span>$p=1$</span> implies the amplitude of the state always damps to the zero state.</p><p>In QuEST directly this is called as</p><pre><code class="language-julia hljs">env = createQuESTEnv()
num_qubits = 1
qureg = createDensityQureg(num_qubits,env)</code></pre><p>The density matrix is</p><pre><code class="language-julia hljs">2×2 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im</code></pre><p>apply an <span>$X$</span> gate</p><pre><code class="language-julia hljs">pauliX(qureg,1)</code></pre><p>gives </p><pre><code class="language-julia hljs">2×2 Matrix{ComplexF64}:
 0.0+0.0im  0.0+0.0im
 0.0+0.0im  1.0+0.0im</code></pre><p>So we are now in the <span>$1$</span> state. Lets apply the damping function.</p><pre><code class="language-julia hljs">p = .33
mixDamping(qureg,1,p)</code></pre><p>gives</p><pre><code class="language-julia hljs">2×2 Matrix{ComplexF64}:
 0.33+0.0im   0.0+0.0im
  0.0+0.0im  0.67+0.0im</code></pre><p>Note that the function <code>get_qureg_matrix(qureg::Qureg)</code> will return the state vector or density matrix when called. The amplitudes of the <span>$1$</span> state have &quot;damped&quot; proportionally to the propbability of the damping function.</p><h3 id="Key-takeaways-for-the-damping-decoherence-model"><a class="docs-heading-anchor" href="#Key-takeaways-for-the-damping-decoherence-model">Key takeaways for the damping decoherence model</a><a id="Key-takeaways-for-the-damping-decoherence-model-1"></a><a class="docs-heading-anchor-permalink" href="#Key-takeaways-for-the-damping-decoherence-model" title="Permalink"></a></h3><h2 id="Dephasing"><a class="docs-heading-anchor" href="#Dephasing">Dephasing</a><a id="Dephasing-1"></a><a class="docs-heading-anchor-permalink" href="#Dephasing" title="Permalink"></a></h2><p>To run a dephasing noise within the verification framework recall</p><pre><code class="language-julia hljs"># Dephasing
p = [p_scale*rand() for i in vertices(para[:graph])]
model = Dephasing(Quest(),SingleQubit(),p)
server = NoisyServer(model)
vbqc_outcome = run_verification_simulator(server,Verbose(),para)</code></pre><h3 id="Example-of-Dephasing-directly-in-QuEST"><a class="docs-heading-anchor" href="#Example-of-Dephasing-directly-in-QuEST">Example of Dephasing directly in QuEST</a><a id="Example-of-Dephasing-directly-in-QuEST-1"></a><a class="docs-heading-anchor-permalink" href="#Example-of-Dephasing-directly-in-QuEST" title="Permalink"></a></h3><p>With probability, <span>$0 \le p \le 1/2$</span> a Paulia <span>$Z$</span> gate is mixed with a density matrix qureg, <span>$\rho$</span> to results in a single qubit dephasing noise on qubit, <span>$q$</span>. </p><p class="math-container">\[\rho \rightarrow (1-p)\rho +p Z_q \rho Z_q\]</p><p>We set up a density qureg.</p><pre><code class="language-julia hljs">env = createQuESTEnv()
num_qubits = 1
qureg = createDensityQureg(num_qubits,env)</code></pre><p>Get the details of the state</p><pre><code class="language-julia hljs">2×2 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im</code></pre><p>Apply a Pauli <span>$Y$</span> gate,</p><pre><code class="language-julia hljs">rotateY(qureg,1,π/4)</code></pre><p>with state details,</p><pre><code class="language-julia hljs">2×2 Matrix{ComplexF64}:
 0.853553+0.0im  0.353553+0.0im
 0.353553+0.0im  0.146447+0.0im</code></pre><p>then apply a maximally mixed dephasing gate</p><pre><code class="language-julia hljs">p = 0.5
mixDephasing(qureg,1,p)</code></pre><p>with new state now</p><pre><code class="language-julia hljs">2×2 Matrix{ComplexF64}:
 0.853553+0.0im       0.0+0.0im
      0.0+0.0im  0.146447+0.0im</code></pre><h3 id="Key-takeaways-for-the-dephasing-decoherence-model"><a class="docs-heading-anchor" href="#Key-takeaways-for-the-dephasing-decoherence-model">Key takeaways for the dephasing decoherence model</a><a id="Key-takeaways-for-the-dephasing-decoherence-model-1"></a><a class="docs-heading-anchor-permalink" href="#Key-takeaways-for-the-dephasing-decoherence-model" title="Permalink"></a></h3><h2 id="Depolarising"><a class="docs-heading-anchor" href="#Depolarising">Depolarising</a><a id="Depolarising-1"></a><a class="docs-heading-anchor-permalink" href="#Depolarising" title="Permalink"></a></h2><p>To run a depolarising noise within the verification framework recall</p><pre><code class="language-julia hljs"># Depolarising
p = [p_scale*rand() for i in vertices(para[:graph])]
model = Depolarising(Quest(),SingleQubit(),p)
server = NoisyServer(model)
vbqc_outcome = run_verification_simulator(server,Verbose(),para)</code></pre><h3 id="Example-of-depolarising-directly-in-QuEST"><a class="docs-heading-anchor" href="#Example-of-depolarising-directly-in-QuEST">Example of depolarising directly in QuEST</a><a id="Example-of-depolarising-directly-in-QuEST-1"></a><a class="docs-heading-anchor-permalink" href="#Example-of-depolarising-directly-in-QuEST" title="Permalink"></a></h3><p>Depolarising noise mixes a density qureg to result in single-qubit homogeneous depolarising noise. Like Dephasing noise, with probability <span>$p$</span> a uniformly random noise is appied to qubit <span>$q$</span>. The applied noise is either Pauli <span>$X$</span>, <span>$Y$</span>, or <span>$Z$</span> to <span>$q$</span>.</p><p class="math-container">\[\rho \rightarrow (1-p)\rho +\frac{p}{3} X_q \rho X_q + Y_q \rho Y_q + Z_q \rho Z_q,\]</p><p>note that <span>$p$</span> has an upper bound of <span>$3/4$</span>, where maximal mixing occurs and is equivalent to</p><p class="math-container">\[\rho \rightarrow \left(1 - \frac{4}{3}p\right)\rho + \left(\frac{4}{3}p \right)\frac{\bar{1}}{2},\]</p><p>where <span>$\frac{\bar{1}}{2}$</span> is the maximally mixed state of <span>$q$</span>.</p><p>In QuEST directly this is called as</p><pre><code class="language-julia hljs">env = createQuESTEnv()
num_qubits = 1
qureg = createDensityQureg(num_qubits,env)</code></pre><p>The density matrix is</p><pre><code class="language-julia hljs">2×2 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im</code></pre><p>Apply, as before a <span>$Y$</span> gate,</p><pre><code class="language-julia hljs">rotateY(qureg,1,π/4)</code></pre><p>which has state,</p><pre><code class="language-julia hljs">2×2 Matrix{ComplexF64}:
 0.853553+0.0im  0.353553+0.0im
 0.353553+0.0im  0.146447+0.0im</code></pre><p>then apply a depolarising noise,</p><pre><code class="language-julia hljs">p = 0.5
mixDepolarising(qureg,1,p)</code></pre><p>which has state</p><pre><code class="language-julia hljs">2×2 Matrix{ComplexF64}:
0.617851+0.0im  0.117851+0.0im
0.117851+0.0im  0.382149+0.0im</code></pre><h3 id="Key-takeaways-for-the-depolarising-decoherence-model"><a class="docs-heading-anchor" href="#Key-takeaways-for-the-depolarising-decoherence-model">Key takeaways for the depolarising decoherence model</a><a id="Key-takeaways-for-the-depolarising-decoherence-model-1"></a><a class="docs-heading-anchor-permalink" href="#Key-takeaways-for-the-depolarising-decoherence-model" title="Permalink"></a></h3><h2 id="Pauli"><a class="docs-heading-anchor" href="#Pauli">Pauli</a><a id="Pauli-1"></a><a class="docs-heading-anchor-permalink" href="#Pauli" title="Permalink"></a></h2><p>To run a Pauli noise within the verification framework recall</p><pre><code class="language-julia hljs"># Pauli
p_xyz(p_scale) = p_scale .* [rand(),rand(),rand()]
p = [p_xyz(p_scale) for i in vertices(para[:graph])]
model = Pauli(Quest(),SingleQubit(),p)
server = NoisyServer(model)
vbqc_outcome = run_verification_simulator(server,Verbose(),para)</code></pre><p>Note that the Pauli probabilities is a vector of three differently drawn values. This is to account of the <span>$X\times Y\times Z$</span> directions.</p><h3 id="Example-of-Pauli-directly-in-QuEST"><a class="docs-heading-anchor" href="#Example-of-Pauli-directly-in-QuEST">Example of Pauli directly in QuEST</a><a id="Example-of-Pauli-directly-in-QuEST-1"></a><a class="docs-heading-anchor-permalink" href="#Example-of-Pauli-directly-in-QuEST" title="Permalink"></a></h3><p>In QuEST directly this is called as</p><pre><code class="language-julia hljs">env = createQuESTEnv()
num_qubits = 1
qureg = createDensityQureg(num_qubits,env)</code></pre><p>The density matrix is</p><pre><code class="language-julia hljs">2×2 Matrix{ComplexF64}:
 1.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im</code></pre><h3 id="Key-takeaways-for-the-Pauli-decoherence-model"><a class="docs-heading-anchor" href="#Key-takeaways-for-the-Pauli-decoherence-model">Key takeaways for the Pauli decoherence model</a><a id="Key-takeaways-for-the-Pauli-decoherence-model-1"></a><a class="docs-heading-anchor-permalink" href="#Key-takeaways-for-the-Pauli-decoherence-model" title="Permalink"></a></h3></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/">« Getting Started</a><a class="docs-footer-nextpage" href="../grover_example/">Grover example »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Monday 3 June 2024 17:07">Monday 3 June 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
